{
  "markdown": "[コンテンツにスキップ](https://openai.github.io/openai-agents-python/ja/ref/result/#results)\n\n# `Results`\n\n### RunResultBase`dataclass`\n\nBases: `ABC`\n\nSource code in `src/agents/result.py`\n\n|     |     |\n| --- | --- |\n| ```<br> 38<br> 39<br> 40<br> 41<br> 42<br> 43<br> 44<br> 45<br> 46<br> 47<br> 48<br> 49<br> 50<br> 51<br> 52<br> 53<br> 54<br> 55<br> 56<br> 57<br> 58<br> 59<br> 60<br> 61<br> 62<br> 63<br> 64<br> 65<br> 66<br> 67<br> 68<br> 69<br> 70<br> 71<br> 72<br> 73<br> 74<br> 75<br> 76<br> 77<br> 78<br> 79<br> 80<br> 81<br> 82<br> 83<br> 84<br> 85<br> 86<br> 87<br> 88<br> 89<br> 90<br> 91<br> 92<br> 93<br> 94<br> 95<br> 96<br> 97<br> 98<br> 99<br>100<br>101<br>``` | ```md-code__content<br>@dataclass<br>class RunResultBase(abc.ABC):<br>    input: str | list[TResponseInputItem]<br>    \"\"\"The original input items i.e. the items before run() was called. This may be a mutated<br>    version of the input, if there are handoff input filters that mutate the input.<br>    \"\"\"<br>    new_items: list[RunItem]<br>    \"\"\"The new items generated during the agent run. These include things like new messages, tool<br>    calls and their outputs, etc.<br>    \"\"\"<br>    raw_responses: list[ModelResponse]<br>    \"\"\"The raw LLM responses generated by the model during the agent run.\"\"\"<br>    final_output: Any<br>    \"\"\"The output of the last agent.\"\"\"<br>    input_guardrail_results: list[InputGuardrailResult]<br>    \"\"\"Guardrail results for the input messages.\"\"\"<br>    output_guardrail_results: list[OutputGuardrailResult]<br>    \"\"\"Guardrail results for the final output of the agent.\"\"\"<br>    context_wrapper: RunContextWrapper[Any]<br>    \"\"\"The context wrapper for the agent run.\"\"\"<br>    @property<br>    @abc.abstractmethod<br>    def last_agent(self) -> Agent[Any]:<br>        \"\"\"The last agent that was run.\"\"\"<br>    def final_output_as(self, cls: type[T], raise_if_incorrect_type: bool = False) -> T:<br>        \"\"\"A convenience method to cast the final output to a specific type. By default, the cast<br>        is only for the typechecker. If you set `raise_if_incorrect_type` to True, we'll raise a<br>        TypeError if the final output is not of the given type.<br>        Args:<br>            cls: The type to cast the final output to.<br>            raise_if_incorrect_type: If True, we'll raise a TypeError if the final output is not of<br>                the given type.<br>        Returns:<br>            The final output casted to the given type.<br>        \"\"\"<br>        if raise_if_incorrect_type and not isinstance(self.final_output, cls):<br>            raise TypeError(f\"Final output is not of type {cls.__name__}\")<br>        return cast(T, self.final_output)<br>    def to_input_list(self) -> list[TResponseInputItem]:<br>        \"\"\"Creates a new input list, merging the original input with all the new items generated.\"\"\"<br>        original_items: list[TResponseInputItem] = ItemHelpers.input_to_new_input_list(self.input)<br>        new_items = [item.to_input_item() for item in self.new_items]<br>        return original_items + new_items<br>    @property<br>    def last_response_id(self) -> str | None:<br>        \"\"\"Convenience method to get the response ID of the last model response.\"\"\"<br>        if not self.raw_responses:<br>            return None<br>        return self.raw_responses[-1].response_id<br>``` |\n\n#### input`instance-attribute`\n\n```md-code__content\ninput: str | list[TResponseInputItem]\n\n```\n\nThe original input items i.e. the items before run() was called. This may be a mutated\nversion of the input, if there are handoff input filters that mutate the input.\n\n#### new\\_items`instance-attribute`\n\n```md-code__content\nnew_items: list[RunItem]\n\n```\n\nThe new items generated during the agent run. These include things like new messages, tool\ncalls and their outputs, etc.\n\n#### raw\\_responses`instance-attribute`\n\n```md-code__content\nraw_responses: list[ModelResponse]\n\n```\n\nThe raw LLM responses generated by the model during the agent run.\n\n#### final\\_output`instance-attribute`\n\n```md-code__content\nfinal_output: Any\n\n```\n\nThe output of the last agent.\n\n#### input\\_guardrail\\_results`instance-attribute`\n\n```md-code__content\ninput_guardrail_results: list[InputGuardrailResult]\n\n```\n\nGuardrail results for the input messages.\n\n#### output\\_guardrail\\_results`instance-attribute`\n\n```md-code__content\noutput_guardrail_results: list[OutputGuardrailResult]\n\n```\n\nGuardrail results for the final output of the agent.\n\n#### context\\_wrapper`instance-attribute`\n\n```md-code__content\ncontext_wrapper: RunContextWrapper[Any]\n\n```\n\nThe context wrapper for the agent run.\n\n#### last\\_agent`abstractmethod``property`\n\n```md-code__content\nlast_agent: Agent[Any]\n\n```\n\nThe last agent that was run.\n\n#### last\\_response\\_id`property`\n\n```md-code__content\nlast_response_id: str | None\n\n```\n\nConvenience method to get the response ID of the last model response.\n\n#### final\\_output\\_as\n\n```md-code__content\nfinal_output_as(\n    cls: type[T], raise_if_incorrect_type: bool = False\n) -> T\n\n```\n\nA convenience method to cast the final output to a specific type. By default, the cast\nis only for the typechecker. If you set `raise_if_incorrect_type` to True, we'll raise a\nTypeError if the final output is not of the given type.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `cls` | `type[T]` | The type to cast the final output to. | _required_ |\n| `raise_if_incorrect_type` | `bool` | If True, we'll raise a TypeError if the final output is not of<br>the given type. | `False` |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `T` | The final output casted to the given type. |\n\nSource code in `src/agents/result.py`\n\n|     |     |\n| --- | --- |\n| ```<br>70<br>71<br>72<br>73<br>74<br>75<br>76<br>77<br>78<br>79<br>80<br>81<br>82<br>83<br>84<br>85<br>86<br>``` | ```md-code__content<br>def final_output_as(self, cls: type[T], raise_if_incorrect_type: bool = False) -> T:<br>    \"\"\"A convenience method to cast the final output to a specific type. By default, the cast<br>    is only for the typechecker. If you set `raise_if_incorrect_type` to True, we'll raise a<br>    TypeError if the final output is not of the given type.<br>    Args:<br>        cls: The type to cast the final output to.<br>        raise_if_incorrect_type: If True, we'll raise a TypeError if the final output is not of<br>            the given type.<br>    Returns:<br>        The final output casted to the given type.<br>    \"\"\"<br>    if raise_if_incorrect_type and not isinstance(self.final_output, cls):<br>        raise TypeError(f\"Final output is not of type {cls.__name__}\")<br>    return cast(T, self.final_output)<br>``` |\n\n#### to\\_input\\_list\n\n```md-code__content\nto_input_list() -> list[TResponseInputItem]\n\n```\n\nCreates a new input list, merging the original input with all the new items generated.\n\nSource code in `src/agents/result.py`\n\n|     |     |\n| --- | --- |\n| ```<br>88<br>89<br>90<br>91<br>92<br>93<br>``` | ```md-code__content<br>def to_input_list(self) -> list[TResponseInputItem]:<br>    \"\"\"Creates a new input list, merging the original input with all the new items generated.\"\"\"<br>    original_items: list[TResponseInputItem] = ItemHelpers.input_to_new_input_list(self.input)<br>    new_items = [item.to_input_item() for item in self.new_items]<br>    return original_items + new_items<br>``` |\n\n### RunResult`dataclass`\n\nBases: `RunResultBase`\n\nSource code in `src/agents/result.py`\n\n|     |     |\n| --- | --- |\n| ```<br>104<br>105<br>106<br>107<br>108<br>109<br>110<br>111<br>112<br>113<br>114<br>``` | ```md-code__content<br>@dataclass<br>class RunResult(RunResultBase):<br>    _last_agent: Agent[Any]<br>    @property<br>    def last_agent(self) -> Agent[Any]:<br>        \"\"\"The last agent that was run.\"\"\"<br>        return self._last_agent<br>    def __str__(self) -> str:<br>        return pretty_print_result(self)<br>``` |\n\n#### last\\_agent`property`\n\n```md-code__content\nlast_agent: Agent[Any]\n\n```\n\nThe last agent that was run.\n\n#### input`instance-attribute`\n\n```md-code__content\ninput: str | list[TResponseInputItem]\n\n```\n\nThe original input items i.e. the items before run() was called. This may be a mutated\nversion of the input, if there are handoff input filters that mutate the input.\n\n#### new\\_items`instance-attribute`\n\n```md-code__content\nnew_items: list[RunItem]\n\n```\n\nThe new items generated during the agent run. These include things like new messages, tool\ncalls and their outputs, etc.\n\n#### raw\\_responses`instance-attribute`\n\n```md-code__content\nraw_responses: list[ModelResponse]\n\n```\n\nThe raw LLM responses generated by the model during the agent run.\n\n#### final\\_output`instance-attribute`\n\n```md-code__content\nfinal_output: Any\n\n```\n\nThe output of the last agent.\n\n#### input\\_guardrail\\_results`instance-attribute`\n\n```md-code__content\ninput_guardrail_results: list[InputGuardrailResult]\n\n```\n\nGuardrail results for the input messages.\n\n#### output\\_guardrail\\_results`instance-attribute`\n\n```md-code__content\noutput_guardrail_results: list[OutputGuardrailResult]\n\n```\n\nGuardrail results for the final output of the agent.\n\n#### context\\_wrapper`instance-attribute`\n\n```md-code__content\ncontext_wrapper: RunContextWrapper[Any]\n\n```\n\nThe context wrapper for the agent run.\n\n#### last\\_response\\_id`property`\n\n```md-code__content\nlast_response_id: str | None\n\n```\n\nConvenience method to get the response ID of the last model response.\n\n#### final\\_output\\_as\n\n```md-code__content\nfinal_output_as(\n    cls: type[T], raise_if_incorrect_type: bool = False\n) -> T\n\n```\n\nA convenience method to cast the final output to a specific type. By default, the cast\nis only for the typechecker. If you set `raise_if_incorrect_type` to True, we'll raise a\nTypeError if the final output is not of the given type.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `cls` | `type[T]` | The type to cast the final output to. | _required_ |\n| `raise_if_incorrect_type` | `bool` | If True, we'll raise a TypeError if the final output is not of<br>the given type. | `False` |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `T` | The final output casted to the given type. |\n\nSource code in `src/agents/result.py`\n\n|     |     |\n| --- | --- |\n| ```<br>70<br>71<br>72<br>73<br>74<br>75<br>76<br>77<br>78<br>79<br>80<br>81<br>82<br>83<br>84<br>85<br>86<br>``` | ```md-code__content<br>def final_output_as(self, cls: type[T], raise_if_incorrect_type: bool = False) -> T:<br>    \"\"\"A convenience method to cast the final output to a specific type. By default, the cast<br>    is only for the typechecker. If you set `raise_if_incorrect_type` to True, we'll raise a<br>    TypeError if the final output is not of the given type.<br>    Args:<br>        cls: The type to cast the final output to.<br>        raise_if_incorrect_type: If True, we'll raise a TypeError if the final output is not of<br>            the given type.<br>    Returns:<br>        The final output casted to the given type.<br>    \"\"\"<br>    if raise_if_incorrect_type and not isinstance(self.final_output, cls):<br>        raise TypeError(f\"Final output is not of type {cls.__name__}\")<br>    return cast(T, self.final_output)<br>``` |\n\n#### to\\_input\\_list\n\n```md-code__content\nto_input_list() -> list[TResponseInputItem]\n\n```\n\nCreates a new input list, merging the original input with all the new items generated.\n\nSource code in `src/agents/result.py`\n\n|     |     |\n| --- | --- |\n| ```<br>88<br>89<br>90<br>91<br>92<br>93<br>``` | ```md-code__content<br>def to_input_list(self) -> list[TResponseInputItem]:<br>    \"\"\"Creates a new input list, merging the original input with all the new items generated.\"\"\"<br>    original_items: list[TResponseInputItem] = ItemHelpers.input_to_new_input_list(self.input)<br>    new_items = [item.to_input_item() for item in self.new_items]<br>    return original_items + new_items<br>``` |\n\n### RunResultStreaming`dataclass`\n\nBases: `RunResultBase`\n\nThe result of an agent run in streaming mode. You can use the `stream_events` method to\nreceive semantic events as they are generated.\n\nThe streaming method will raise:\n\\- A MaxTurnsExceeded exception if the agent exceeds the max\\_turns limit.\n\\- A GuardrailTripwireTriggered exception if a guardrail is tripped.\n\nSource code in `src/agents/result.py`\n\n|     |     |\n| --- | --- |\n| ```<br>117<br>118<br>119<br>120<br>121<br>122<br>123<br>124<br>125<br>126<br>127<br>128<br>129<br>130<br>131<br>132<br>133<br>134<br>135<br>136<br>137<br>138<br>139<br>140<br>141<br>142<br>143<br>144<br>145<br>146<br>147<br>148<br>149<br>150<br>151<br>152<br>153<br>154<br>155<br>156<br>157<br>158<br>159<br>160<br>161<br>162<br>163<br>164<br>165<br>166<br>167<br>168<br>169<br>170<br>171<br>172<br>173<br>174<br>175<br>176<br>177<br>178<br>179<br>180<br>181<br>182<br>183<br>184<br>185<br>186<br>187<br>188<br>189<br>190<br>191<br>192<br>193<br>194<br>195<br>196<br>197<br>198<br>199<br>200<br>201<br>202<br>203<br>204<br>205<br>206<br>207<br>208<br>209<br>210<br>211<br>212<br>213<br>214<br>215<br>216<br>217<br>218<br>219<br>220<br>221<br>222<br>223<br>224<br>225<br>226<br>227<br>228<br>229<br>230<br>231<br>232<br>233<br>234<br>235<br>236<br>237<br>238<br>239<br>240<br>241<br>242<br>243<br>244<br>245<br>246<br>247<br>248<br>249<br>250<br>251<br>252<br>253<br>254<br>255<br>256<br>257<br>258<br>259<br>260<br>261<br>262<br>263<br>264<br>265<br>266<br>267<br>268<br>269<br>270<br>271<br>272<br>273<br>274<br>275<br>276<br>``` | ```md-code__content<br>@dataclass<br>class RunResultStreaming(RunResultBase):<br>    \"\"\"The result of an agent run in streaming mode. You can use the `stream_events` method to<br>    receive semantic events as they are generated.<br>    The streaming method will raise:<br>    - A MaxTurnsExceeded exception if the agent exceeds the max_turns limit.<br>    - A GuardrailTripwireTriggered exception if a guardrail is tripped.<br>    \"\"\"<br>    current_agent: Agent[Any]<br>    \"\"\"The current agent that is running.\"\"\"<br>    current_turn: int<br>    \"\"\"The current turn number.\"\"\"<br>    max_turns: int<br>    \"\"\"The maximum number of turns the agent can run for.\"\"\"<br>    final_output: Any<br>    \"\"\"The final output of the agent. This is None until the agent has finished running.\"\"\"<br>    _current_agent_output_schema: AgentOutputSchemaBase | None = field(repr=False)<br>    trace: Trace | None = field(repr=False)<br>    is_complete: bool = False<br>    \"\"\"Whether the agent has finished running.\"\"\"<br>    # Queues that the background run_loop writes to<br>    _event_queue: asyncio.Queue[StreamEvent | QueueCompleteSentinel] = field(<br>        default_factory=asyncio.Queue, repr=False<br>    )<br>    _input_guardrail_queue: asyncio.Queue[InputGuardrailResult] = field(<br>        default_factory=asyncio.Queue, repr=False<br>    )<br>    # Store the asyncio tasks that we're waiting on<br>    _run_impl_task: asyncio.Task[Any] | None = field(default=None, repr=False)<br>    _input_guardrails_task: asyncio.Task[Any] | None = field(default=None, repr=False)<br>    _output_guardrails_task: asyncio.Task[Any] | None = field(default=None, repr=False)<br>    _stored_exception: Exception | None = field(default=None, repr=False)<br>    @property<br>    def last_agent(self) -> Agent[Any]:<br>        \"\"\"The last agent that was run. Updates as the agent run progresses, so the true last agent<br>        is only available after the agent run is complete.<br>        \"\"\"<br>        return self.current_agent<br>    def cancel(self) -> None:<br>        \"\"\"Cancels the streaming run, stopping all background tasks and marking the run as<br>        complete.\"\"\"<br>        self._cleanup_tasks()  # Cancel all running tasks<br>        self.is_complete = True  # Mark the run as complete to stop event streaming<br>        # Optionally, clear the event queue to prevent processing stale events<br>        while not self._event_queue.empty():<br>            self._event_queue.get_nowait()<br>        while not self._input_guardrail_queue.empty():<br>            self._input_guardrail_queue.get_nowait()<br>    async def stream_events(self) -> AsyncIterator[StreamEvent]:<br>        \"\"\"Stream deltas for new items as they are generated. We're using the types from the<br>        OpenAI Responses API, so these are semantic events: each event has a `type` field that<br>        describes the type of the event, along with the data for that event.<br>        This will raise:<br>        - A MaxTurnsExceeded exception if the agent exceeds the max_turns limit.<br>        - A GuardrailTripwireTriggered exception if a guardrail is tripped.<br>        \"\"\"<br>        while True:<br>            self._check_errors()<br>            if self._stored_exception:<br>                logger.debug(\"Breaking due to stored exception\")<br>                self.is_complete = True<br>                break<br>            if self.is_complete and self._event_queue.empty():<br>                break<br>            try:<br>                item = await self._event_queue.get()<br>            except asyncio.CancelledError:<br>                break<br>            if isinstance(item, QueueCompleteSentinel):<br>                self._event_queue.task_done()<br>                # Check for errors, in case the queue was completed due to an exception<br>                self._check_errors()<br>                break<br>            yield item<br>            self._event_queue.task_done()<br>        self._cleanup_tasks()<br>        if self._stored_exception:<br>            raise self._stored_exception<br>    def _create_error_details(self) -> RunErrorDetails:<br>        \"\"\"Return a `RunErrorDetails` object considering the current attributes of the class.\"\"\"<br>        return RunErrorDetails(<br>            input=self.input,<br>            new_items=self.new_items,<br>            raw_responses=self.raw_responses,<br>            last_agent=self.current_agent,<br>            context_wrapper=self.context_wrapper,<br>            input_guardrail_results=self.input_guardrail_results,<br>            output_guardrail_results=self.output_guardrail_results,<br>        )<br>    def _check_errors(self):<br>        if self.current_turn > self.max_turns:<br>            max_turns_exc = MaxTurnsExceeded(f\"Max turns ({self.max_turns}) exceeded\")<br>            max_turns_exc.run_data = self._create_error_details()<br>            self._stored_exception = max_turns_exc<br>        # Fetch all the completed guardrail results from the queue and raise if needed<br>        while not self._input_guardrail_queue.empty():<br>            guardrail_result = self._input_guardrail_queue.get_nowait()<br>            if guardrail_result.output.tripwire_triggered:<br>                tripwire_exc = InputGuardrailTripwireTriggered(guardrail_result)<br>                tripwire_exc.run_data = self._create_error_details()<br>                self._stored_exception = tripwire_exc<br>        # Check the tasks for any exceptions<br>        if self._run_impl_task and self._run_impl_task.done():<br>            run_impl_exc = self._run_impl_task.exception()<br>            if run_impl_exc and isinstance(run_impl_exc, Exception):<br>                if isinstance(run_impl_exc, AgentsException) and run_impl_exc.run_data is None:<br>                    run_impl_exc.run_data = self._create_error_details()<br>                self._stored_exception = run_impl_exc<br>        if self._input_guardrails_task and self._input_guardrails_task.done():<br>            in_guard_exc = self._input_guardrails_task.exception()<br>            if in_guard_exc and isinstance(in_guard_exc, Exception):<br>                if isinstance(in_guard_exc, AgentsException) and in_guard_exc.run_data is None:<br>                    in_guard_exc.run_data = self._create_error_details()<br>                self._stored_exception = in_guard_exc<br>        if self._output_guardrails_task and self._output_guardrails_task.done():<br>            out_guard_exc = self._output_guardrails_task.exception()<br>            if out_guard_exc and isinstance(out_guard_exc, Exception):<br>                if isinstance(out_guard_exc, AgentsException) and out_guard_exc.run_data is None:<br>                    out_guard_exc.run_data = self._create_error_details()<br>                self._stored_exception = out_guard_exc<br>    def _cleanup_tasks(self):<br>        if self._run_impl_task and not self._run_impl_task.done():<br>            self._run_impl_task.cancel()<br>        if self._input_guardrails_task and not self._input_guardrails_task.done():<br>            self._input_guardrails_task.cancel()<br>        if self._output_guardrails_task and not self._output_guardrails_task.done():<br>            self._output_guardrails_task.cancel()<br>    def __str__(self) -> str:<br>        return pretty_print_run_result_streaming(self)<br>``` |\n\n#### current\\_agent`instance-attribute`\n\n```md-code__content\ncurrent_agent: Agent[Any]\n\n```\n\nThe current agent that is running.\n\n#### current\\_turn`instance-attribute`\n\n```md-code__content\ncurrent_turn: int\n\n```\n\nThe current turn number.\n\n#### max\\_turns`instance-attribute`\n\n```md-code__content\nmax_turns: int\n\n```\n\nThe maximum number of turns the agent can run for.\n\n#### final\\_output`instance-attribute`\n\n```md-code__content\nfinal_output: Any\n\n```\n\nThe final output of the agent. This is None until the agent has finished running.\n\n#### is\\_complete`class-attribute``instance-attribute`\n\n```md-code__content\nis_complete: bool = False\n\n```\n\nWhether the agent has finished running.\n\n#### last\\_agent`property`\n\n```md-code__content\nlast_agent: Agent[Any]\n\n```\n\nThe last agent that was run. Updates as the agent run progresses, so the true last agent\nis only available after the agent run is complete.\n\n#### input`instance-attribute`\n\n```md-code__content\ninput: str | list[TResponseInputItem]\n\n```\n\nThe original input items i.e. the items before run() was called. This may be a mutated\nversion of the input, if there are handoff input filters that mutate the input.\n\n#### new\\_items`instance-attribute`\n\n```md-code__content\nnew_items: list[RunItem]\n\n```\n\nThe new items generated during the agent run. These include things like new messages, tool\ncalls and their outputs, etc.\n\n#### raw\\_responses`instance-attribute`\n\n```md-code__content\nraw_responses: list[ModelResponse]\n\n```\n\nThe raw LLM responses generated by the model during the agent run.\n\n#### input\\_guardrail\\_results`instance-attribute`\n\n```md-code__content\ninput_guardrail_results: list[InputGuardrailResult]\n\n```\n\nGuardrail results for the input messages.\n\n#### output\\_guardrail\\_results`instance-attribute`\n\n```md-code__content\noutput_guardrail_results: list[OutputGuardrailResult]\n\n```\n\nGuardrail results for the final output of the agent.\n\n#### context\\_wrapper`instance-attribute`\n\n```md-code__content\ncontext_wrapper: RunContextWrapper[Any]\n\n```\n\nThe context wrapper for the agent run.\n\n#### last\\_response\\_id`property`\n\n```md-code__content\nlast_response_id: str | None\n\n```\n\nConvenience method to get the response ID of the last model response.\n\n#### cancel\n\n```md-code__content\ncancel() -> None\n\n```\n\nCancels the streaming run, stopping all background tasks and marking the run as\ncomplete.\n\nSource code in `src/agents/result.py`\n\n|     |     |\n| --- | --- |\n| ```<br>167<br>168<br>169<br>170<br>171<br>172<br>173<br>174<br>175<br>176<br>177<br>``` | ```md-code__content<br>def cancel(self) -> None:<br>    \"\"\"Cancels the streaming run, stopping all background tasks and marking the run as<br>    complete.\"\"\"<br>    self._cleanup_tasks()  # Cancel all running tasks<br>    self.is_complete = True  # Mark the run as complete to stop event streaming<br>    # Optionally, clear the event queue to prevent processing stale events<br>    while not self._event_queue.empty():<br>        self._event_queue.get_nowait()<br>    while not self._input_guardrail_queue.empty():<br>        self._input_guardrail_queue.get_nowait()<br>``` |\n\n#### stream\\_events`async`\n\n```md-code__content\nstream_events() -> AsyncIterator[StreamEvent]\n\n```\n\nStream deltas for new items as they are generated. We're using the types from the\nOpenAI Responses API, so these are semantic events: each event has a `type` field that\ndescribes the type of the event, along with the data for that event.\n\nThis will raise:\n\\- A MaxTurnsExceeded exception if the agent exceeds the max\\_turns limit.\n\\- A GuardrailTripwireTriggered exception if a guardrail is tripped.\n\nSource code in `src/agents/result.py`\n\n|     |     |\n| --- | --- |\n| ```<br>179<br>180<br>181<br>182<br>183<br>184<br>185<br>186<br>187<br>188<br>189<br>190<br>191<br>192<br>193<br>194<br>195<br>196<br>197<br>198<br>199<br>200<br>201<br>202<br>203<br>204<br>205<br>206<br>207<br>208<br>209<br>210<br>211<br>212<br>213<br>214<br>215<br>``` | ```md-code__content<br>async def stream_events(self) -> AsyncIterator[StreamEvent]:<br>    \"\"\"Stream deltas for new items as they are generated. We're using the types from the<br>    OpenAI Responses API, so these are semantic events: each event has a `type` field that<br>    describes the type of the event, along with the data for that event.<br>    This will raise:<br>    - A MaxTurnsExceeded exception if the agent exceeds the max_turns limit.<br>    - A GuardrailTripwireTriggered exception if a guardrail is tripped.<br>    \"\"\"<br>    while True:<br>        self._check_errors()<br>        if self._stored_exception:<br>            logger.debug(\"Breaking due to stored exception\")<br>            self.is_complete = True<br>            break<br>        if self.is_complete and self._event_queue.empty():<br>            break<br>        try:<br>            item = await self._event_queue.get()<br>        except asyncio.CancelledError:<br>            break<br>        if isinstance(item, QueueCompleteSentinel):<br>            self._event_queue.task_done()<br>            # Check for errors, in case the queue was completed due to an exception<br>            self._check_errors()<br>            break<br>        yield item<br>        self._event_queue.task_done()<br>    self._cleanup_tasks()<br>    if self._stored_exception:<br>        raise self._stored_exception<br>``` |\n\n#### final\\_output\\_as\n\n```md-code__content\nfinal_output_as(\n    cls: type[T], raise_if_incorrect_type: bool = False\n) -> T\n\n```\n\nA convenience method to cast the final output to a specific type. By default, the cast\nis only for the typechecker. If you set `raise_if_incorrect_type` to True, we'll raise a\nTypeError if the final output is not of the given type.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `cls` | `type[T]` | The type to cast the final output to. | _required_ |\n| `raise_if_incorrect_type` | `bool` | If True, we'll raise a TypeError if the final output is not of<br>the given type. | `False` |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `T` | The final output casted to the given type. |\n\nSource code in `src/agents/result.py`\n\n|     |     |\n| --- | --- |\n| ```<br>70<br>71<br>72<br>73<br>74<br>75<br>76<br>77<br>78<br>79<br>80<br>81<br>82<br>83<br>84<br>85<br>86<br>``` | ```md-code__content<br>def final_output_as(self, cls: type[T], raise_if_incorrect_type: bool = False) -> T:<br>    \"\"\"A convenience method to cast the final output to a specific type. By default, the cast<br>    is only for the typechecker. If you set `raise_if_incorrect_type` to True, we'll raise a<br>    TypeError if the final output is not of the given type.<br>    Args:<br>        cls: The type to cast the final output to.<br>        raise_if_incorrect_type: If True, we'll raise a TypeError if the final output is not of<br>            the given type.<br>    Returns:<br>        The final output casted to the given type.<br>    \"\"\"<br>    if raise_if_incorrect_type and not isinstance(self.final_output, cls):<br>        raise TypeError(f\"Final output is not of type {cls.__name__}\")<br>    return cast(T, self.final_output)<br>``` |\n\n#### to\\_input\\_list\n\n```md-code__content\nto_input_list() -> list[TResponseInputItem]\n\n```\n\nCreates a new input list, merging the original input with all the new items generated.\n\nSource code in `src/agents/result.py`\n\n|     |     |\n| --- | --- |\n| ```<br>88<br>89<br>90<br>91<br>92<br>93<br>``` | ```md-code__content<br>def to_input_list(self) -> list[TResponseInputItem]:<br>    \"\"\"Creates a new input list, merging the original input with all the new items generated.\"\"\"<br>    original_items: list[TResponseInputItem] = ItemHelpers.input_to_new_input_list(self.input)<br>    new_items = [item.to_input_item() for item in self.new_items]<br>    return original_items + new_items<br>``` |",
  "metadata": {
    "favicon": "https://openai.github.io/openai-agents-python/images/favicon-platform.svg",
    "generator": "mkdocs-1.6.1, mkdocs-material-9.6.11",
    "viewport": "width=device-width,initial-scale=1",
    "language": "ja",
    "title": "Results - OpenAI Agents SDK",
    "scrapeId": "bba0defe-cad4-429a-bbda-f68a9bf4143f",
    "sourceURL": "https://openai.github.io/openai-agents-python/ja/ref/result/",
    "url": "https://openai.github.io/openai-agents-python/ja/ref/result/",
    "statusCode": 200,
    "contentType": "text/html; charset=utf-8",
    "proxyUsed": "basic"
  }
}