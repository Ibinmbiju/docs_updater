{
  "markdown": "[コンテンツにスキップ](https://openai.github.io/openai-agents-python/ja/ref/tracing/#tracing-module)\n\n# Tracing module\n\n### TraceProvider\n\nBases: `ABC`\n\nInterface for creating traces and spans.\n\nSource code in `src/agents/tracing/provider.py`\n\n|     |     |\n| --- | --- |\n| ```<br> 85<br> 86<br> 87<br> 88<br> 89<br> 90<br> 91<br> 92<br> 93<br> 94<br> 95<br> 96<br> 97<br> 98<br> 99<br>100<br>101<br>102<br>103<br>104<br>105<br>106<br>107<br>108<br>109<br>110<br>111<br>112<br>113<br>114<br>115<br>116<br>117<br>118<br>119<br>120<br>121<br>122<br>123<br>124<br>125<br>126<br>127<br>128<br>129<br>130<br>131<br>132<br>133<br>134<br>135<br>136<br>137<br>138<br>139<br>140<br>141<br>142<br>143<br>144<br>145<br>146<br>147<br>``` | ```md-code__content<br>class TraceProvider(ABC):<br>    \"\"\"Interface for creating traces and spans.\"\"\"<br>    @abstractmethod<br>    def register_processor(self, processor: TracingProcessor) -> None:<br>        \"\"\"Add a processor that will receive all traces and spans.\"\"\"<br>    @abstractmethod<br>    def set_processors(self, processors: list[TracingProcessor]) -> None:<br>        \"\"\"Replace the list of processors with ``processors``.\"\"\"<br>    @abstractmethod<br>    def get_current_trace(self) -> Trace | None:<br>        \"\"\"Return the currently active trace, if any.\"\"\"<br>    @abstractmethod<br>    def get_current_span(self) -> Span[Any] | None:<br>        \"\"\"Return the currently active span, if any.\"\"\"<br>    @abstractmethod<br>    def set_disabled(self, disabled: bool) -> None:<br>        \"\"\"Enable or disable tracing globally.\"\"\"<br>    @abstractmethod<br>    def time_iso(self) -> str:<br>        \"\"\"Return the current time in ISO 8601 format.\"\"\"<br>    @abstractmethod<br>    def gen_trace_id(self) -> str:<br>        \"\"\"Generate a new trace identifier.\"\"\"<br>    @abstractmethod<br>    def gen_span_id(self) -> str:<br>        \"\"\"Generate a new span identifier.\"\"\"<br>    @abstractmethod<br>    def gen_group_id(self) -> str:<br>        \"\"\"Generate a new group identifier.\"\"\"<br>    @abstractmethod<br>    def create_trace(<br>        self,<br>        name: str,<br>        trace_id: str | None = None,<br>        group_id: str | None = None,<br>        metadata: dict[str, Any] | None = None,<br>        disabled: bool = False,<br>    ) -> Trace:<br>        \"\"\"Create a new trace.\"\"\"<br>    @abstractmethod<br>    def create_span(<br>        self,<br>        span_data: TSpanData,<br>        span_id: str | None = None,<br>        parent: Trace | Span[Any] | None = None,<br>        disabled: bool = False,<br>    ) -> Span[TSpanData]:<br>        \"\"\"Create a new span.\"\"\"<br>    @abstractmethod<br>    def shutdown(self) -> None:<br>        \"\"\"Clean up any resources used by the provider.\"\"\"<br>``` |\n\n#### register\\_processor`abstractmethod`\n\n```md-code__content\nregister_processor(processor: TracingProcessor) -> None\n\n```\n\nAdd a processor that will receive all traces and spans.\n\nSource code in `src/agents/tracing/provider.py`\n\n|     |     |\n| --- | --- |\n| ```<br>88<br>89<br>90<br>``` | ```md-code__content<br>@abstractmethod<br>def register_processor(self, processor: TracingProcessor) -> None:<br>    \"\"\"Add a processor that will receive all traces and spans.\"\"\"<br>``` |\n\n#### set\\_processors`abstractmethod`\n\n```md-code__content\nset_processors(processors: list[TracingProcessor]) -> None\n\n```\n\nReplace the list of processors with `processors`.\n\nSource code in `src/agents/tracing/provider.py`\n\n|     |     |\n| --- | --- |\n| ```<br>92<br>93<br>94<br>``` | ```md-code__content<br>@abstractmethod<br>def set_processors(self, processors: list[TracingProcessor]) -> None:<br>    \"\"\"Replace the list of processors with ``processors``.\"\"\"<br>``` |\n\n#### get\\_current\\_trace`abstractmethod`\n\n```md-code__content\nget_current_trace() -> Trace | None\n\n```\n\nReturn the currently active trace, if any.\n\nSource code in `src/agents/tracing/provider.py`\n\n|     |     |\n| --- | --- |\n| ```<br>96<br>97<br>98<br>``` | ```md-code__content<br>@abstractmethod<br>def get_current_trace(self) -> Trace | None:<br>    \"\"\"Return the currently active trace, if any.\"\"\"<br>``` |\n\n#### get\\_current\\_span`abstractmethod`\n\n```md-code__content\nget_current_span() -> Span[Any] | None\n\n```\n\nReturn the currently active span, if any.\n\nSource code in `src/agents/tracing/provider.py`\n\n|     |     |\n| --- | --- |\n| ```<br>100<br>101<br>102<br>``` | ```md-code__content<br>@abstractmethod<br>def get_current_span(self) -> Span[Any] | None:<br>    \"\"\"Return the currently active span, if any.\"\"\"<br>``` |\n\n#### set\\_disabled`abstractmethod`\n\n```md-code__content\nset_disabled(disabled: bool) -> None\n\n```\n\nEnable or disable tracing globally.\n\nSource code in `src/agents/tracing/provider.py`\n\n|     |     |\n| --- | --- |\n| ```<br>104<br>105<br>106<br>``` | ```md-code__content<br>@abstractmethod<br>def set_disabled(self, disabled: bool) -> None:<br>    \"\"\"Enable or disable tracing globally.\"\"\"<br>``` |\n\n#### time\\_iso`abstractmethod`\n\n```md-code__content\ntime_iso() -> str\n\n```\n\nReturn the current time in ISO 8601 format.\n\nSource code in `src/agents/tracing/provider.py`\n\n|     |     |\n| --- | --- |\n| ```<br>108<br>109<br>110<br>``` | ```md-code__content<br>@abstractmethod<br>def time_iso(self) -> str:<br>    \"\"\"Return the current time in ISO 8601 format.\"\"\"<br>``` |\n\n#### gen\\_trace\\_id`abstractmethod`\n\n```md-code__content\ngen_trace_id() -> str\n\n```\n\nGenerate a new trace identifier.\n\nSource code in `src/agents/tracing/provider.py`\n\n|     |     |\n| --- | --- |\n| ```<br>112<br>113<br>114<br>``` | ```md-code__content<br>@abstractmethod<br>def gen_trace_id(self) -> str:<br>    \"\"\"Generate a new trace identifier.\"\"\"<br>``` |\n\n#### gen\\_span\\_id`abstractmethod`\n\n```md-code__content\ngen_span_id() -> str\n\n```\n\nGenerate a new span identifier.\n\nSource code in `src/agents/tracing/provider.py`\n\n|     |     |\n| --- | --- |\n| ```<br>116<br>117<br>118<br>``` | ```md-code__content<br>@abstractmethod<br>def gen_span_id(self) -> str:<br>    \"\"\"Generate a new span identifier.\"\"\"<br>``` |\n\n#### gen\\_group\\_id`abstractmethod`\n\n```md-code__content\ngen_group_id() -> str\n\n```\n\nGenerate a new group identifier.\n\nSource code in `src/agents/tracing/provider.py`\n\n|     |     |\n| --- | --- |\n| ```<br>120<br>121<br>122<br>``` | ```md-code__content<br>@abstractmethod<br>def gen_group_id(self) -> str:<br>    \"\"\"Generate a new group identifier.\"\"\"<br>``` |\n\n#### create\\_trace`abstractmethod`\n\n```md-code__content\ncreate_trace(\n    name: str,\n    trace_id: str | None = None,\n    group_id: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    disabled: bool = False,\n) -> Trace\n\n```\n\nCreate a new trace.\n\nSource code in `src/agents/tracing/provider.py`\n\n|     |     |\n| --- | --- |\n| ```<br>124<br>125<br>126<br>127<br>128<br>129<br>130<br>131<br>132<br>133<br>``` | ```md-code__content<br>@abstractmethod<br>def create_trace(<br>    self,<br>    name: str,<br>    trace_id: str | None = None,<br>    group_id: str | None = None,<br>    metadata: dict[str, Any] | None = None,<br>    disabled: bool = False,<br>) -> Trace:<br>    \"\"\"Create a new trace.\"\"\"<br>``` |\n\n#### create\\_span`abstractmethod`\n\n```md-code__content\ncreate_span(\n    span_data: TSpanData,\n    span_id: str | None = None,\n    parent: Trace | Span[Any] | None = None,\n    disabled: bool = False,\n) -> Span[TSpanData]\n\n```\n\nCreate a new span.\n\nSource code in `src/agents/tracing/provider.py`\n\n|     |     |\n| --- | --- |\n| ```<br>135<br>136<br>137<br>138<br>139<br>140<br>141<br>142<br>143<br>``` | ```md-code__content<br>@abstractmethod<br>def create_span(<br>    self,<br>    span_data: TSpanData,<br>    span_id: str | None = None,<br>    parent: Trace | Span[Any] | None = None,<br>    disabled: bool = False,<br>) -> Span[TSpanData]:<br>    \"\"\"Create a new span.\"\"\"<br>``` |\n\n#### shutdown`abstractmethod`\n\n```md-code__content\nshutdown() -> None\n\n```\n\nClean up any resources used by the provider.\n\nSource code in `src/agents/tracing/provider.py`\n\n|     |     |\n| --- | --- |\n| ```<br>145<br>146<br>147<br>``` | ```md-code__content<br>@abstractmethod<br>def shutdown(self) -> None:<br>    \"\"\"Clean up any resources used by the provider.\"\"\"<br>``` |\n\n### TracingProcessor\n\nBases: `ABC`\n\nInterface for processing spans.\n\nSource code in `src/agents/tracing/processor_interface.py`\n\n|     |     |\n| --- | --- |\n| ```<br> 9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>``` | ```md-code__content<br>class TracingProcessor(abc.ABC):<br>    \"\"\"Interface for processing spans.\"\"\"<br>    @abc.abstractmethod<br>    def on_trace_start(self, trace: \"Trace\") -> None:<br>        \"\"\"Called when a trace is started.<br>        Args:<br>            trace: The trace that started.<br>        \"\"\"<br>        pass<br>    @abc.abstractmethod<br>    def on_trace_end(self, trace: \"Trace\") -> None:<br>        \"\"\"Called when a trace is finished.<br>        Args:<br>            trace: The trace that started.<br>        \"\"\"<br>        pass<br>    @abc.abstractmethod<br>    def on_span_start(self, span: \"Span[Any]\") -> None:<br>        \"\"\"Called when a span is started.<br>        Args:<br>            span: The span that started.<br>        \"\"\"<br>        pass<br>    @abc.abstractmethod<br>    def on_span_end(self, span: \"Span[Any]\") -> None:<br>        \"\"\"Called when a span is finished. Should not block or raise exceptions.<br>        Args:<br>            span: The span that finished.<br>        \"\"\"<br>        pass<br>    @abc.abstractmethod<br>    def shutdown(self) -> None:<br>        \"\"\"Called when the application stops.\"\"\"<br>        pass<br>    @abc.abstractmethod<br>    def force_flush(self) -> None:<br>        \"\"\"Forces an immediate flush of all queued spans/traces.\"\"\"<br>        pass<br>``` |\n\n#### on\\_trace\\_start`abstractmethod`\n\n```md-code__content\non_trace_start(trace: Trace) -> None\n\n```\n\nCalled when a trace is started.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `trace` | `Trace` | The trace that started. | _required_ |\n\nSource code in `src/agents/tracing/processor_interface.py`\n\n|     |     |\n| --- | --- |\n| ```<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>``` | ```md-code__content<br>@abc.abstractmethod<br>def on_trace_start(self, trace: \"Trace\") -> None:<br>    \"\"\"Called when a trace is started.<br>    Args:<br>        trace: The trace that started.<br>    \"\"\"<br>    pass<br>``` |\n\n#### on\\_trace\\_end`abstractmethod`\n\n```md-code__content\non_trace_end(trace: Trace) -> None\n\n```\n\nCalled when a trace is finished.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `trace` | `Trace` | The trace that started. | _required_ |\n\nSource code in `src/agents/tracing/processor_interface.py`\n\n|     |     |\n| --- | --- |\n| ```<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>``` | ```md-code__content<br>@abc.abstractmethod<br>def on_trace_end(self, trace: \"Trace\") -> None:<br>    \"\"\"Called when a trace is finished.<br>    Args:<br>        trace: The trace that started.<br>    \"\"\"<br>    pass<br>``` |\n\n#### on\\_span\\_start`abstractmethod`\n\n```md-code__content\non_span_start(span: Span[Any]) -> None\n\n```\n\nCalled when a span is started.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `span` | `Span[Any]` | The span that started. | _required_ |\n\nSource code in `src/agents/tracing/processor_interface.py`\n\n|     |     |\n| --- | --- |\n| ```<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>``` | ```md-code__content<br>@abc.abstractmethod<br>def on_span_start(self, span: \"Span[Any]\") -> None:<br>    \"\"\"Called when a span is started.<br>    Args:<br>        span: The span that started.<br>    \"\"\"<br>    pass<br>``` |\n\n#### on\\_span\\_end`abstractmethod`\n\n```md-code__content\non_span_end(span: Span[Any]) -> None\n\n```\n\nCalled when a span is finished. Should not block or raise exceptions.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `span` | `Span[Any]` | The span that finished. | _required_ |\n\nSource code in `src/agents/tracing/processor_interface.py`\n\n|     |     |\n| --- | --- |\n| ```<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>``` | ```md-code__content<br>@abc.abstractmethod<br>def on_span_end(self, span: \"Span[Any]\") -> None:<br>    \"\"\"Called when a span is finished. Should not block or raise exceptions.<br>    Args:<br>        span: The span that finished.<br>    \"\"\"<br>    pass<br>``` |\n\n#### shutdown`abstractmethod`\n\n```md-code__content\nshutdown() -> None\n\n```\n\nCalled when the application stops.\n\nSource code in `src/agents/tracing/processor_interface.py`\n\n|     |     |\n| --- | --- |\n| ```<br>48<br>49<br>50<br>51<br>``` | ```md-code__content<br>@abc.abstractmethod<br>def shutdown(self) -> None:<br>    \"\"\"Called when the application stops.\"\"\"<br>    pass<br>``` |\n\n#### force\\_flush`abstractmethod`\n\n```md-code__content\nforce_flush() -> None\n\n```\n\nForces an immediate flush of all queued spans/traces.\n\nSource code in `src/agents/tracing/processor_interface.py`\n\n|     |     |\n| --- | --- |\n| ```<br>53<br>54<br>55<br>56<br>``` | ```md-code__content<br>@abc.abstractmethod<br>def force_flush(self) -> None:<br>    \"\"\"Forces an immediate flush of all queued spans/traces.\"\"\"<br>    pass<br>``` |\n\n### AgentSpanData\n\nBases: `SpanData`\n\nRepresents an Agent Span in the trace.\nIncludes name, handoffs, tools, and output type.\n\nSource code in `src/agents/tracing/span_data.py`\n\n|     |     |\n| --- | --- |\n| ```<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>``` | ```md-code__content<br>class AgentSpanData(SpanData):<br>    \"\"\"<br>    Represents an Agent Span in the trace.<br>    Includes name, handoffs, tools, and output type.<br>    \"\"\"<br>    __slots__ = (\"name\", \"handoffs\", \"tools\", \"output_type\")<br>    def __init__(<br>        self,<br>        name: str,<br>        handoffs: list[str] | None = None,<br>        tools: list[str] | None = None,<br>        output_type: str | None = None,<br>    ):<br>        self.name = name<br>        self.handoffs: list[str] | None = handoffs<br>        self.tools: list[str] | None = tools<br>        self.output_type: str | None = output_type<br>    @property<br>    def type(self) -> str:<br>        return \"agent\"<br>    def export(self) -> dict[str, Any]:<br>        return {<br>            \"type\": self.type,<br>            \"name\": self.name,<br>            \"handoffs\": self.handoffs,<br>            \"tools\": self.tools,<br>            \"output_type\": self.output_type,<br>        }<br>``` |\n\n### CustomSpanData\n\nBases: `SpanData`\n\nRepresents a Custom Span in the trace.\nIncludes name and data property bag.\n\nSource code in `src/agents/tracing/span_data.py`\n\n|     |     |\n| --- | --- |\n| ```<br>192<br>193<br>194<br>195<br>196<br>197<br>198<br>199<br>200<br>201<br>202<br>203<br>204<br>205<br>206<br>207<br>208<br>209<br>210<br>211<br>212<br>213<br>``` | ```md-code__content<br>class CustomSpanData(SpanData):<br>    \"\"\"<br>    Represents a Custom Span in the trace.<br>    Includes name and data property bag.<br>    \"\"\"<br>    __slots__ = (\"name\", \"data\")<br>    def __init__(self, name: str, data: dict[str, Any]):<br>        self.name = name<br>        self.data = data<br>    @property<br>    def type(self) -> str:<br>        return \"custom\"<br>    def export(self) -> dict[str, Any]:<br>        return {<br>            \"type\": self.type,<br>            \"name\": self.name,<br>            \"data\": self.data,<br>        }<br>``` |\n\n### FunctionSpanData\n\nBases: `SpanData`\n\nRepresents a Function Span in the trace.\nIncludes input, output and MCP data (if applicable).\n\nSource code in `src/agents/tracing/span_data.py`\n\n|     |     |\n| --- | --- |\n| ```<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>72<br>73<br>74<br>75<br>76<br>77<br>78<br>79<br>80<br>81<br>82<br>83<br>84<br>85<br>86<br>87<br>88<br>89<br>90<br>91<br>92<br>93<br>``` | ```md-code__content<br>class FunctionSpanData(SpanData):<br>    \"\"\"<br>    Represents a Function Span in the trace.<br>    Includes input, output and MCP data (if applicable).<br>    \"\"\"<br>    __slots__ = (\"name\", \"input\", \"output\", \"mcp_data\")<br>    def __init__(<br>        self,<br>        name: str,<br>        input: str | None,<br>        output: Any | None,<br>        mcp_data: dict[str, Any] | None = None,<br>    ):<br>        self.name = name<br>        self.input = input<br>        self.output = output<br>        self.mcp_data = mcp_data<br>    @property<br>    def type(self) -> str:<br>        return \"function\"<br>    def export(self) -> dict[str, Any]:<br>        return {<br>            \"type\": self.type,<br>            \"name\": self.name,<br>            \"input\": self.input,<br>            \"output\": str(self.output) if self.output else None,<br>            \"mcp_data\": self.mcp_data,<br>        }<br>``` |\n\n### GenerationSpanData\n\nBases: `SpanData`\n\nRepresents a Generation Span in the trace.\nIncludes input, output, model, model configuration, and usage.\n\nSource code in `src/agents/tracing/span_data.py`\n\n|     |     |\n| --- | --- |\n| ```<br> 96<br> 97<br> 98<br> 99<br>100<br>101<br>102<br>103<br>104<br>105<br>106<br>107<br>108<br>109<br>110<br>111<br>112<br>113<br>114<br>115<br>116<br>117<br>118<br>119<br>120<br>121<br>122<br>123<br>124<br>125<br>126<br>127<br>128<br>129<br>130<br>131<br>132<br>133<br>134<br>135<br>136<br>``` | ```md-code__content<br>class GenerationSpanData(SpanData):<br>    \"\"\"<br>    Represents a Generation Span in the trace.<br>    Includes input, output, model, model configuration, and usage.<br>    \"\"\"<br>    __slots__ = (<br>        \"input\",<br>        \"output\",<br>        \"model\",<br>        \"model_config\",<br>        \"usage\",<br>    )<br>    def __init__(<br>        self,<br>        input: Sequence[Mapping[str, Any]] | None = None,<br>        output: Sequence[Mapping[str, Any]] | None = None,<br>        model: str | None = None,<br>        model_config: Mapping[str, Any] | None = None,<br>        usage: dict[str, Any] | None = None,<br>    ):<br>        self.input = input<br>        self.output = output<br>        self.model = model<br>        self.model_config = model_config<br>        self.usage = usage<br>    @property<br>    def type(self) -> str:<br>        return \"generation\"<br>    def export(self) -> dict[str, Any]:<br>        return {<br>            \"type\": self.type,<br>            \"input\": self.input,<br>            \"output\": self.output,<br>            \"model\": self.model,<br>            \"model_config\": self.model_config,<br>            \"usage\": self.usage,<br>        }<br>``` |\n\n### GuardrailSpanData\n\nBases: `SpanData`\n\nRepresents a Guardrail Span in the trace.\nIncludes name and triggered status.\n\nSource code in `src/agents/tracing/span_data.py`\n\n|     |     |\n| --- | --- |\n| ```<br>216<br>217<br>218<br>219<br>220<br>221<br>222<br>223<br>224<br>225<br>226<br>227<br>228<br>229<br>230<br>231<br>232<br>233<br>234<br>235<br>236<br>237<br>``` | ```md-code__content<br>class GuardrailSpanData(SpanData):<br>    \"\"\"<br>    Represents a Guardrail Span in the trace.<br>    Includes name and triggered status.<br>    \"\"\"<br>    __slots__ = (\"name\", \"triggered\")<br>    def __init__(self, name: str, triggered: bool = False):<br>        self.name = name<br>        self.triggered = triggered<br>    @property<br>    def type(self) -> str:<br>        return \"guardrail\"<br>    def export(self) -> dict[str, Any]:<br>        return {<br>            \"type\": self.type,<br>            \"name\": self.name,<br>            \"triggered\": self.triggered,<br>        }<br>``` |\n\n### HandoffSpanData\n\nBases: `SpanData`\n\nRepresents a Handoff Span in the trace.\nIncludes source and destination agents.\n\nSource code in `src/agents/tracing/span_data.py`\n\n|     |     |\n| --- | --- |\n| ```<br>168<br>169<br>170<br>171<br>172<br>173<br>174<br>175<br>176<br>177<br>178<br>179<br>180<br>181<br>182<br>183<br>184<br>185<br>186<br>187<br>188<br>189<br>``` | ```md-code__content<br>class HandoffSpanData(SpanData):<br>    \"\"\"<br>    Represents a Handoff Span in the trace.<br>    Includes source and destination agents.<br>    \"\"\"<br>    __slots__ = (\"from_agent\", \"to_agent\")<br>    def __init__(self, from_agent: str | None, to_agent: str | None):<br>        self.from_agent = from_agent<br>        self.to_agent = to_agent<br>    @property<br>    def type(self) -> str:<br>        return \"handoff\"<br>    def export(self) -> dict[str, Any]:<br>        return {<br>            \"type\": self.type,<br>            \"from_agent\": self.from_agent,<br>            \"to_agent\": self.to_agent,<br>        }<br>``` |\n\n### MCPListToolsSpanData\n\nBases: `SpanData`\n\nRepresents an MCP List Tools Span in the trace.\nIncludes server and result.\n\nSource code in `src/agents/tracing/span_data.py`\n\n|     |     |\n| --- | --- |\n| ```<br>350<br>351<br>352<br>353<br>354<br>355<br>356<br>357<br>358<br>359<br>360<br>361<br>362<br>363<br>364<br>365<br>366<br>367<br>368<br>369<br>370<br>371<br>372<br>373<br>374<br>``` | ```md-code__content<br>class MCPListToolsSpanData(SpanData):<br>    \"\"\"<br>    Represents an MCP List Tools Span in the trace.<br>    Includes server and result.<br>    \"\"\"<br>    __slots__ = (<br>        \"server\",<br>        \"result\",<br>    )<br>    def __init__(self, server: str | None = None, result: list[str] | None = None):<br>        self.server = server<br>        self.result = result<br>    @property<br>    def type(self) -> str:<br>        return \"mcp_tools\"<br>    def export(self) -> dict[str, Any]:<br>        return {<br>            \"type\": self.type,<br>            \"server\": self.server,<br>            \"result\": self.result,<br>        }<br>``` |\n\n### ResponseSpanData\n\nBases: `SpanData`\n\nRepresents a Response Span in the trace.\nIncludes response and input.\n\nSource code in `src/agents/tracing/span_data.py`\n\n|     |     |\n| --- | --- |\n| ```<br>139<br>140<br>141<br>142<br>143<br>144<br>145<br>146<br>147<br>148<br>149<br>150<br>151<br>152<br>153<br>154<br>155<br>156<br>157<br>158<br>159<br>160<br>161<br>162<br>163<br>164<br>165<br>``` | ```md-code__content<br>class ResponseSpanData(SpanData):<br>    \"\"\"<br>    Represents a Response Span in the trace.<br>    Includes response and input.<br>    \"\"\"<br>    __slots__ = (\"response\", \"input\")<br>    def __init__(<br>        self,<br>        response: Response | None = None,<br>        input: str | list[ResponseInputItemParam] | None = None,<br>    ) -> None:<br>        self.response = response<br>        # This is not used by the OpenAI trace processors, but is useful for other tracing<br>        # processor implementations<br>        self.input = input<br>    @property<br>    def type(self) -> str:<br>        return \"response\"<br>    def export(self) -> dict[str, Any]:<br>        return {<br>            \"type\": self.type,<br>            \"response_id\": self.response.id if self.response else None,<br>        }<br>``` |\n\n### SpanData\n\nBases: `ABC`\n\nRepresents span data in the trace.\n\nSource code in `src/agents/tracing/span_data.py`\n\n|     |     |\n| --- | --- |\n| ```<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>``` | ```md-code__content<br>class SpanData(abc.ABC):<br>    \"\"\"<br>    Represents span data in the trace.<br>    \"\"\"<br>    @abc.abstractmethod<br>    def export(self) -> dict[str, Any]:<br>        \"\"\"Export the span data as a dictionary.\"\"\"<br>        pass<br>    @property<br>    @abc.abstractmethod<br>    def type(self) -> str:<br>        \"\"\"Return the type of the span.\"\"\"<br>        pass<br>``` |\n\n#### type`abstractmethod``property`\n\n```md-code__content\ntype: str\n\n```\n\nReturn the type of the span.\n\n#### export`abstractmethod`\n\n```md-code__content\nexport() -> dict[str, Any]\n\n```\n\nExport the span data as a dictionary.\n\nSource code in `src/agents/tracing/span_data.py`\n\n|     |     |\n| --- | --- |\n| ```<br>16<br>17<br>18<br>19<br>``` | ```md-code__content<br>@abc.abstractmethod<br>def export(self) -> dict[str, Any]:<br>    \"\"\"Export the span data as a dictionary.\"\"\"<br>    pass<br>``` |\n\n### SpeechGroupSpanData\n\nBases: `SpanData`\n\nRepresents a Speech Group Span in the trace.\n\nSource code in `src/agents/tracing/span_data.py`\n\n|     |     |\n| --- | --- |\n| ```<br>326<br>327<br>328<br>329<br>330<br>331<br>332<br>333<br>334<br>335<br>336<br>337<br>338<br>339<br>340<br>341<br>342<br>343<br>344<br>345<br>346<br>347<br>``` | ```md-code__content<br>class SpeechGroupSpanData(SpanData):<br>    \"\"\"<br>    Represents a Speech Group Span in the trace.<br>    \"\"\"<br>    __slots__ = \"input\"<br>    def __init__(<br>        self,<br>        input: str | None = None,<br>    ):<br>        self.input = input<br>    @property<br>    def type(self) -> str:<br>        return \"speech_group\"<br>    def export(self) -> dict[str, Any]:<br>        return {<br>            \"type\": self.type,<br>            \"input\": self.input,<br>        }<br>``` |\n\n### SpeechSpanData\n\nBases: `SpanData`\n\nRepresents a Speech Span in the trace.\nIncludes input, output, model, model configuration, and first content timestamp.\n\nSource code in `src/agents/tracing/span_data.py`\n\n|     |     |\n| --- | --- |\n| ```<br>284<br>285<br>286<br>287<br>288<br>289<br>290<br>291<br>292<br>293<br>294<br>295<br>296<br>297<br>298<br>299<br>300<br>301<br>302<br>303<br>304<br>305<br>306<br>307<br>308<br>309<br>310<br>311<br>312<br>313<br>314<br>315<br>316<br>317<br>318<br>319<br>320<br>321<br>322<br>323<br>``` | ```md-code__content<br>class SpeechSpanData(SpanData):<br>    \"\"\"<br>    Represents a Speech Span in the trace.<br>    Includes input, output, model, model configuration, and first content timestamp.<br>    \"\"\"<br>    __slots__ = (\"input\", \"output\", \"model\", \"model_config\", \"first_content_at\")<br>    def __init__(<br>        self,<br>        input: str | None = None,<br>        output: str | None = None,<br>        output_format: str | None = \"pcm\",<br>        model: str | None = None,<br>        model_config: Mapping[str, Any] | None = None,<br>        first_content_at: str | None = None,<br>    ):<br>        self.input = input<br>        self.output = output<br>        self.output_format = output_format<br>        self.model = model<br>        self.model_config = model_config<br>        self.first_content_at = first_content_at<br>    @property<br>    def type(self) -> str:<br>        return \"speech\"<br>    def export(self) -> dict[str, Any]:<br>        return {<br>            \"type\": self.type,<br>            \"input\": self.input,<br>            \"output\": {<br>                \"data\": self.output or \"\",<br>                \"format\": self.output_format,<br>            },<br>            \"model\": self.model,<br>            \"model_config\": self.model_config,<br>            \"first_content_at\": self.first_content_at,<br>        }<br>``` |\n\n### TranscriptionSpanData\n\nBases: `SpanData`\n\nRepresents a Transcription Span in the trace.\nIncludes input, output, model, and model configuration.\n\nSource code in `src/agents/tracing/span_data.py`\n\n|     |     |\n| --- | --- |\n| ```<br>240<br>241<br>242<br>243<br>244<br>245<br>246<br>247<br>248<br>249<br>250<br>251<br>252<br>253<br>254<br>255<br>256<br>257<br>258<br>259<br>260<br>261<br>262<br>263<br>264<br>265<br>266<br>267<br>268<br>269<br>270<br>271<br>272<br>273<br>274<br>275<br>276<br>277<br>278<br>279<br>280<br>281<br>``` | ```md-code__content<br>class TranscriptionSpanData(SpanData):<br>    \"\"\"<br>    Represents a Transcription Span in the trace.<br>    Includes input, output, model, and model configuration.<br>    \"\"\"<br>    __slots__ = (<br>        \"input\",<br>        \"output\",<br>        \"model\",<br>        \"model_config\",<br>    )<br>    def __init__(<br>        self,<br>        input: str | None = None,<br>        input_format: str | None = \"pcm\",<br>        output: str | None = None,<br>        model: str | None = None,<br>        model_config: Mapping[str, Any] | None = None,<br>    ):<br>        self.input = input<br>        self.input_format = input_format<br>        self.output = output<br>        self.model = model<br>        self.model_config = model_config<br>    @property<br>    def type(self) -> str:<br>        return \"transcription\"<br>    def export(self) -> dict[str, Any]:<br>        return {<br>            \"type\": self.type,<br>            \"input\": {<br>                \"data\": self.input or \"\",<br>                \"format\": self.input_format,<br>            },<br>            \"output\": self.output,<br>            \"model\": self.model,<br>            \"model_config\": self.model_config,<br>        }<br>``` |\n\n### Span\n\nBases: `ABC`, `Generic[TSpanData]`\n\nSource code in `src/agents/tracing/spans.py`\n\n|     |     |\n| --- | --- |\n| ```<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>72<br>73<br>74<br>75<br>76<br>77<br>78<br>79<br>80<br>81<br>82<br>83<br>84<br>85<br>86<br>87<br>88<br>89<br>90<br>91<br>92<br>93<br>``` | ```md-code__content<br>class Span(abc.ABC, Generic[TSpanData]):<br>    @property<br>    @abc.abstractmethod<br>    def trace_id(self) -> str:<br>        pass<br>    @property<br>    @abc.abstractmethod<br>    def span_id(self) -> str:<br>        pass<br>    @property<br>    @abc.abstractmethod<br>    def span_data(self) -> TSpanData:<br>        pass<br>    @abc.abstractmethod<br>    def start(self, mark_as_current: bool = False):<br>        \"\"\"<br>        Start the span.<br>        Args:<br>            mark_as_current: If true, the span will be marked as the current span.<br>        \"\"\"<br>        pass<br>    @abc.abstractmethod<br>    def finish(self, reset_current: bool = False) -> None:<br>        \"\"\"<br>        Finish the span.<br>        Args:<br>            reset_current: If true, the span will be reset as the current span.<br>        \"\"\"<br>        pass<br>    @abc.abstractmethod<br>    def __enter__(self) -> Span[TSpanData]:<br>        pass<br>    @abc.abstractmethod<br>    def __exit__(self, exc_type, exc_val, exc_tb):<br>        pass<br>    @property<br>    @abc.abstractmethod<br>    def parent_id(self) -> str | None:<br>        pass<br>    @abc.abstractmethod<br>    def set_error(self, error: SpanError) -> None:<br>        pass<br>    @property<br>    @abc.abstractmethod<br>    def error(self) -> SpanError | None:<br>        pass<br>    @abc.abstractmethod<br>    def export(self) -> dict[str, Any] | None:<br>        pass<br>    @property<br>    @abc.abstractmethod<br>    def started_at(self) -> str | None:<br>        pass<br>    @property<br>    @abc.abstractmethod<br>    def ended_at(self) -> str | None:<br>        pass<br>``` |\n\n#### start`abstractmethod`\n\n```md-code__content\nstart(mark_as_current: bool = False)\n\n```\n\nStart the span.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `mark_as_current` | `bool` | If true, the span will be marked as the current span. | `False` |\n\nSource code in `src/agents/tracing/spans.py`\n\n|     |     |\n| --- | --- |\n| ```<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>``` | ```md-code__content<br>@abc.abstractmethod<br>def start(self, mark_as_current: bool = False):<br>    \"\"\"<br>    Start the span.<br>    Args:<br>        mark_as_current: If true, the span will be marked as the current span.<br>    \"\"\"<br>    pass<br>``` |\n\n#### finish`abstractmethod`\n\n```md-code__content\nfinish(reset_current: bool = False) -> None\n\n```\n\nFinish the span.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `reset_current` | `bool` | If true, the span will be reset as the current span. | `False` |\n\nSource code in `src/agents/tracing/spans.py`\n\n|     |     |\n| --- | --- |\n| ```<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>``` | ```md-code__content<br>@abc.abstractmethod<br>def finish(self, reset_current: bool = False) -> None:<br>    \"\"\"<br>    Finish the span.<br>    Args:<br>        reset_current: If true, the span will be reset as the current span.<br>    \"\"\"<br>    pass<br>``` |\n\n### Trace\n\nA trace is the root level object that tracing creates. It represents a logical \"workflow\".\n\nSource code in `src/agents/tracing/traces.py`\n\n|     |     |\n| --- | --- |\n| ```<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>``` | ```md-code__content<br>class Trace:<br>    \"\"\"<br>    A trace is the root level object that tracing creates. It represents a logical \"workflow\".<br>    \"\"\"<br>    @abc.abstractmethod<br>    def __enter__(self) -> Trace:<br>        pass<br>    @abc.abstractmethod<br>    def __exit__(self, exc_type, exc_val, exc_tb):<br>        pass<br>    @abc.abstractmethod<br>    def start(self, mark_as_current: bool = False):<br>        \"\"\"<br>        Start the trace.<br>        Args:<br>            mark_as_current: If true, the trace will be marked as the current trace.<br>        \"\"\"<br>        pass<br>    @abc.abstractmethod<br>    def finish(self, reset_current: bool = False):<br>        \"\"\"<br>        Finish the trace.<br>        Args:<br>            reset_current: If true, the trace will be reset as the current trace.<br>        \"\"\"<br>        pass<br>    @property<br>    @abc.abstractmethod<br>    def trace_id(self) -> str:<br>        \"\"\"<br>        The trace ID.<br>        \"\"\"<br>        pass<br>    @property<br>    @abc.abstractmethod<br>    def name(self) -> str:<br>        \"\"\"<br>        The name of the workflow being traced.<br>        \"\"\"<br>        pass<br>    @abc.abstractmethod<br>    def export(self) -> dict[str, Any] | None:<br>        \"\"\"<br>        Export the trace as a dictionary.<br>        \"\"\"<br>        pass<br>``` |\n\n#### trace\\_id`abstractmethod``property`\n\n```md-code__content\ntrace_id: str\n\n```\n\nThe trace ID.\n\n#### name`abstractmethod``property`\n\n```md-code__content\nname: str\n\n```\n\nThe name of the workflow being traced.\n\n#### start`abstractmethod`\n\n```md-code__content\nstart(mark_as_current: bool = False)\n\n```\n\nStart the trace.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `mark_as_current` | `bool` | If true, the trace will be marked as the current trace. | `False` |\n\nSource code in `src/agents/tracing/traces.py`\n\n|     |     |\n| --- | --- |\n| ```<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>``` | ```md-code__content<br>@abc.abstractmethod<br>def start(self, mark_as_current: bool = False):<br>    \"\"\"<br>    Start the trace.<br>    Args:<br>        mark_as_current: If true, the trace will be marked as the current trace.<br>    \"\"\"<br>    pass<br>``` |\n\n#### finish`abstractmethod`\n\n```md-code__content\nfinish(reset_current: bool = False)\n\n```\n\nFinish the trace.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `reset_current` | `bool` | If true, the trace will be reset as the current trace. | `False` |\n\nSource code in `src/agents/tracing/traces.py`\n\n|     |     |\n| --- | --- |\n| ```<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>``` | ```md-code__content<br>@abc.abstractmethod<br>def finish(self, reset_current: bool = False):<br>    \"\"\"<br>    Finish the trace.<br>    Args:<br>        reset_current: If true, the trace will be reset as the current trace.<br>    \"\"\"<br>    pass<br>``` |\n\n#### export`abstractmethod`\n\n```md-code__content\nexport() -> dict[str, Any] | None\n\n```\n\nExport the trace as a dictionary.\n\nSource code in `src/agents/tracing/traces.py`\n\n|     |     |\n| --- | --- |\n| ```<br>62<br>63<br>64<br>65<br>66<br>67<br>``` | ```md-code__content<br>@abc.abstractmethod<br>def export(self) -> dict[str, Any] | None:<br>    \"\"\"<br>    Export the trace as a dictionary.<br>    \"\"\"<br>    pass<br>``` |\n\n### agent\\_span\n\n```md-code__content\nagent_span(\n    name: str,\n    handoffs: list[str] | None = None,\n    tools: list[str] | None = None,\n    output_type: str | None = None,\n    span_id: str | None = None,\n    parent: Trace | Span[Any] | None = None,\n    disabled: bool = False,\n) -> Span[AgentSpanData]\n\n```\n\nCreate a new agent span. The span will not be started automatically, you should either do\n`with agent_span() ...` or call `span.start()` \\+ `span.finish()` manually.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `name` | `str` | The name of the agent. | _required_ |\n| `handoffs` | `list[str] | None` | Optional list of agent names to which this agent could hand off control. | `None` |\n| `tools` | `list[str] | None` | Optional list of tool names available to this agent. | `None` |\n| `output_type` | `str | None` | Optional name of the output type produced by the agent. | `None` |\n| `span_id` | `str | None` | The ID of the span. Optional. If not provided, we will generate an ID. We<br>recommend using `util.gen_span_id()` to generate a span ID, to guarantee that IDs are<br>correctly formatted. | `None` |\n| `parent` | `Trace | Span[Any] | None` | The parent span or trace. If not provided, we will automatically use the current<br>trace/span as the parent. | `None` |\n| `disabled` | `bool` | If True, we will return a Span but the Span will not be recorded. | `False` |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `Span[AgentSpanData]` | The newly created agent span. |\n\nSource code in `src/agents/tracing/create.py`\n\n|     |     |\n| --- | --- |\n| ```<br> 84<br> 85<br> 86<br> 87<br> 88<br> 89<br> 90<br> 91<br> 92<br> 93<br> 94<br> 95<br> 96<br> 97<br> 98<br> 99<br>100<br>101<br>102<br>103<br>104<br>105<br>106<br>107<br>108<br>109<br>110<br>111<br>112<br>113<br>114<br>115<br>116<br>``` | ```md-code__content<br>def agent_span(<br>    name: str,<br>    handoffs: list[str] | None = None,<br>    tools: list[str] | None = None,<br>    output_type: str | None = None,<br>    span_id: str | None = None,<br>    parent: Trace | Span[Any] | None = None,<br>    disabled: bool = False,<br>) -> Span[AgentSpanData]:<br>    \"\"\"Create a new agent span. The span will not be started automatically, you should either do<br>    `with agent_span() ...` or call `span.start()` + `span.finish()` manually.<br>    Args:<br>        name: The name of the agent.<br>        handoffs: Optional list of agent names to which this agent could hand off control.<br>        tools: Optional list of tool names available to this agent.<br>        output_type: Optional name of the output type produced by the agent.<br>        span_id: The ID of the span. Optional. If not provided, we will generate an ID. We<br>            recommend using `util.gen_span_id()` to generate a span ID, to guarantee that IDs are<br>            correctly formatted.<br>        parent: The parent span or trace. If not provided, we will automatically use the current<br>            trace/span as the parent.<br>        disabled: If True, we will return a Span but the Span will not be recorded.<br>    Returns:<br>        The newly created agent span.<br>    \"\"\"<br>    return get_trace_provider().create_span(<br>        span_data=AgentSpanData(name=name, handoffs=handoffs, tools=tools, output_type=output_type),<br>        span_id=span_id,<br>        parent=parent,<br>        disabled=disabled,<br>    )<br>``` |\n\n### custom\\_span\n\n```md-code__content\ncustom_span(\n    name: str,\n    data: dict[str, Any] | None = None,\n    span_id: str | None = None,\n    parent: Trace | Span[Any] | None = None,\n    disabled: bool = False,\n) -> Span[CustomSpanData]\n\n```\n\nCreate a new custom span, to which you can add your own metadata. The span will not be\nstarted automatically, you should either do `with custom_span() ...` or call\n`span.start()` \\+ `span.finish()` manually.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `name` | `str` | The name of the custom span. | _required_ |\n| `data` | `dict[str, Any] | None` | Arbitrary structured data to associate with the span. | `None` |\n| `span_id` | `str | None` | The ID of the span. Optional. If not provided, we will generate an ID. We<br>recommend using `util.gen_span_id()` to generate a span ID, to guarantee that IDs are<br>correctly formatted. | `None` |\n| `parent` | `Trace | Span[Any] | None` | The parent span or trace. If not provided, we will automatically use the current<br>trace/span as the parent. | `None` |\n| `disabled` | `bool` | If True, we will return a Span but the Span will not be recorded. | `False` |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `Span[CustomSpanData]` | The newly created custom span. |\n\nSource code in `src/agents/tracing/create.py`\n\n|     |     |\n| --- | --- |\n| ```<br>257<br>258<br>259<br>260<br>261<br>262<br>263<br>264<br>265<br>266<br>267<br>268<br>269<br>270<br>271<br>272<br>273<br>274<br>275<br>276<br>277<br>278<br>279<br>280<br>281<br>282<br>283<br>284<br>285<br>286<br>``` | ```md-code__content<br>def custom_span(<br>    name: str,<br>    data: dict[str, Any] | None = None,<br>    span_id: str | None = None,<br>    parent: Trace | Span[Any] | None = None,<br>    disabled: bool = False,<br>) -> Span[CustomSpanData]:<br>    \"\"\"Create a new custom span, to which you can add your own metadata. The span will not be<br>    started automatically, you should either do `with custom_span() ...` or call<br>    `span.start()` + `span.finish()` manually.<br>    Args:<br>        name: The name of the custom span.<br>        data: Arbitrary structured data to associate with the span.<br>        span_id: The ID of the span. Optional. If not provided, we will generate an ID. We<br>            recommend using `util.gen_span_id()` to generate a span ID, to guarantee that IDs are<br>            correctly formatted.<br>        parent: The parent span or trace. If not provided, we will automatically use the current<br>            trace/span as the parent.<br>        disabled: If True, we will return a Span but the Span will not be recorded.<br>    Returns:<br>        The newly created custom span.<br>    \"\"\"<br>    return get_trace_provider().create_span(<br>        span_data=CustomSpanData(name=name, data=data or {}),<br>        span_id=span_id,<br>        parent=parent,<br>        disabled=disabled,<br>    )<br>``` |\n\n### function\\_span\n\n```md-code__content\nfunction_span(\n    name: str,\n    input: str | None = None,\n    output: str | None = None,\n    span_id: str | None = None,\n    parent: Trace | Span[Any] | None = None,\n    disabled: bool = False,\n) -> Span[FunctionSpanData]\n\n```\n\nCreate a new function span. The span will not be started automatically, you should either do\n`with function_span() ...` or call `span.start()` \\+ `span.finish()` manually.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `name` | `str` | The name of the function. | _required_ |\n| `input` | `str | None` | The input to the function. | `None` |\n| `output` | `str | None` | The output of the function. | `None` |\n| `span_id` | `str | None` | The ID of the span. Optional. If not provided, we will generate an ID. We<br>recommend using `util.gen_span_id()` to generate a span ID, to guarantee that IDs are<br>correctly formatted. | `None` |\n| `parent` | `Trace | Span[Any] | None` | The parent span or trace. If not provided, we will automatically use the current<br>trace/span as the parent. | `None` |\n| `disabled` | `bool` | If True, we will return a Span but the Span will not be recorded. | `False` |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `Span[FunctionSpanData]` | The newly created function span. |\n\nSource code in `src/agents/tracing/create.py`\n\n|     |     |\n| --- | --- |\n| ```<br>119<br>120<br>121<br>122<br>123<br>124<br>125<br>126<br>127<br>128<br>129<br>130<br>131<br>132<br>133<br>134<br>135<br>136<br>137<br>138<br>139<br>140<br>141<br>142<br>143<br>144<br>145<br>146<br>147<br>148<br>149<br>``` | ```md-code__content<br>def function_span(<br>    name: str,<br>    input: str | None = None,<br>    output: str | None = None,<br>    span_id: str | None = None,<br>    parent: Trace | Span[Any] | None = None,<br>    disabled: bool = False,<br>) -> Span[FunctionSpanData]:<br>    \"\"\"Create a new function span. The span will not be started automatically, you should either do<br>    `with function_span() ...` or call `span.start()` + `span.finish()` manually.<br>    Args:<br>        name: The name of the function.<br>        input: The input to the function.<br>        output: The output of the function.<br>        span_id: The ID of the span. Optional. If not provided, we will generate an ID. We<br>            recommend using `util.gen_span_id()` to generate a span ID, to guarantee that IDs are<br>            correctly formatted.<br>        parent: The parent span or trace. If not provided, we will automatically use the current<br>            trace/span as the parent.<br>        disabled: If True, we will return a Span but the Span will not be recorded.<br>    Returns:<br>        The newly created function span.<br>    \"\"\"<br>    return get_trace_provider().create_span(<br>        span_data=FunctionSpanData(name=name, input=input, output=output),<br>        span_id=span_id,<br>        parent=parent,<br>        disabled=disabled,<br>    )<br>``` |\n\n### generation\\_span\n\n```md-code__content\ngeneration_span(\n    input: Sequence[Mapping[str, Any]] | None = None,\n    output: Sequence[Mapping[str, Any]] | None = None,\n    model: str | None = None,\n    model_config: Mapping[str, Any] | None = None,\n    usage: dict[str, Any] | None = None,\n    span_id: str | None = None,\n    parent: Trace | Span[Any] | None = None,\n    disabled: bool = False,\n) -> Span[GenerationSpanData]\n\n```\n\nCreate a new generation span. The span will not be started automatically, you should either\ndo `with generation_span() ...` or call `span.start()` \\+ `span.finish()` manually.\n\nThis span captures the details of a model generation, including the\ninput message sequence, any generated outputs, the model name and\nconfiguration, and usage data. If you only need to capture a model\nresponse identifier, use `response_span()` instead.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `input` | `Sequence[Mapping[str, Any]] | None` | The sequence of input messages sent to the model. | `None` |\n| `output` | `Sequence[Mapping[str, Any]] | None` | The sequence of output messages received from the model. | `None` |\n| `model` | `str | None` | The model identifier used for the generation. | `None` |\n| `model_config` | `Mapping[str, Any] | None` | The model configuration (hyperparameters) used. | `None` |\n| `usage` | `dict[str, Any] | None` | A dictionary of usage information (input tokens, output tokens, etc.). | `None` |\n| `span_id` | `str | None` | The ID of the span. Optional. If not provided, we will generate an ID. We<br>recommend using `util.gen_span_id()` to generate a span ID, to guarantee that IDs are<br>correctly formatted. | `None` |\n| `parent` | `Trace | Span[Any] | None` | The parent span or trace. If not provided, we will automatically use the current<br>trace/span as the parent. | `None` |\n| `disabled` | `bool` | If True, we will return a Span but the Span will not be recorded. | `False` |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `Span[GenerationSpanData]` | The newly created generation span. |\n\nSource code in `src/agents/tracing/create.py`\n\n|     |     |\n| --- | --- |\n| ```<br>152<br>153<br>154<br>155<br>156<br>157<br>158<br>159<br>160<br>161<br>162<br>163<br>164<br>165<br>166<br>167<br>168<br>169<br>170<br>171<br>172<br>173<br>174<br>175<br>176<br>177<br>178<br>179<br>180<br>181<br>182<br>183<br>184<br>185<br>186<br>187<br>188<br>189<br>190<br>191<br>192<br>193<br>194<br>195<br>196<br>197<br>``` | ```md-code__content<br>def generation_span(<br>    input: Sequence[Mapping[str, Any]] | None = None,<br>    output: Sequence[Mapping[str, Any]] | None = None,<br>    model: str | None = None,<br>    model_config: Mapping[str, Any] | None = None,<br>    usage: dict[str, Any] | None = None,<br>    span_id: str | None = None,<br>    parent: Trace | Span[Any] | None = None,<br>    disabled: bool = False,<br>) -> Span[GenerationSpanData]:<br>    \"\"\"Create a new generation span. The span will not be started automatically, you should either<br>    do `with generation_span() ...` or call `span.start()` + `span.finish()` manually.<br>    This span captures the details of a model generation, including the<br>    input message sequence, any generated outputs, the model name and<br>    configuration, and usage data. If you only need to capture a model<br>    response identifier, use `response_span()` instead.<br>    Args:<br>        input: The sequence of input messages sent to the model.<br>        output: The sequence of output messages received from the model.<br>        model: The model identifier used for the generation.<br>        model_config: The model configuration (hyperparameters) used.<br>        usage: A dictionary of usage information (input tokens, output tokens, etc.).<br>        span_id: The ID of the span. Optional. If not provided, we will generate an ID. We<br>            recommend using `util.gen_span_id()` to generate a span ID, to guarantee that IDs are<br>            correctly formatted.<br>        parent: The parent span or trace. If not provided, we will automatically use the current<br>            trace/span as the parent.<br>        disabled: If True, we will return a Span but the Span will not be recorded.<br>    Returns:<br>        The newly created generation span.<br>    \"\"\"<br>    return get_trace_provider().create_span(<br>        span_data=GenerationSpanData(<br>            input=input,<br>            output=output,<br>            model=model,<br>            model_config=model_config,<br>            usage=usage,<br>        ),<br>        span_id=span_id,<br>        parent=parent,<br>        disabled=disabled,<br>    )<br>``` |\n\n### get\\_current\\_span\n\n```md-code__content\nget_current_span() -> Span[Any] | None\n\n```\n\nReturns the currently active span, if present.\n\nSource code in `src/agents/tracing/create.py`\n\n|     |     |\n| --- | --- |\n| ```<br>79<br>80<br>81<br>``` | ```md-code__content<br>def get_current_span() -> Span[Any] | None:<br>    \"\"\"Returns the currently active span, if present.\"\"\"<br>    return get_trace_provider().get_current_span()<br>``` |\n\n### get\\_current\\_trace\n\n```md-code__content\nget_current_trace() -> Trace | None\n\n```\n\nReturns the currently active trace, if present.\n\nSource code in `src/agents/tracing/create.py`\n\n|     |     |\n| --- | --- |\n| ```<br>74<br>75<br>76<br>``` | ```md-code__content<br>def get_current_trace() -> Trace | None:<br>    \"\"\"Returns the currently active trace, if present.\"\"\"<br>    return get_trace_provider().get_current_trace()<br>``` |\n\n### guardrail\\_span\n\n```md-code__content\nguardrail_span(\n    name: str,\n    triggered: bool = False,\n    span_id: str | None = None,\n    parent: Trace | Span[Any] | None = None,\n    disabled: bool = False,\n) -> Span[GuardrailSpanData]\n\n```\n\nCreate a new guardrail span. The span will not be started automatically, you should either\ndo `with guardrail_span() ...` or call `span.start()` \\+ `span.finish()` manually.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `name` | `str` | The name of the guardrail. | _required_ |\n| `triggered` | `bool` | Whether the guardrail was triggered. | `False` |\n| `span_id` | `str | None` | The ID of the span. Optional. If not provided, we will generate an ID. We<br>recommend using `util.gen_span_id()` to generate a span ID, to guarantee that IDs are<br>correctly formatted. | `None` |\n| `parent` | `Trace | Span[Any] | None` | The parent span or trace. If not provided, we will automatically use the current<br>trace/span as the parent. | `None` |\n| `disabled` | `bool` | If True, we will return a Span but the Span will not be recorded. | `False` |\n\nSource code in `src/agents/tracing/create.py`\n\n|     |     |\n| --- | --- |\n| ```<br>289<br>290<br>291<br>292<br>293<br>294<br>295<br>296<br>297<br>298<br>299<br>300<br>301<br>302<br>303<br>304<br>305<br>306<br>307<br>308<br>309<br>310<br>311<br>312<br>313<br>314<br>``` | ```md-code__content<br>def guardrail_span(<br>    name: str,<br>    triggered: bool = False,<br>    span_id: str | None = None,<br>    parent: Trace | Span[Any] | None = None,<br>    disabled: bool = False,<br>) -> Span[GuardrailSpanData]:<br>    \"\"\"Create a new guardrail span. The span will not be started automatically, you should either<br>    do `with guardrail_span() ...` or call `span.start()` + `span.finish()` manually.<br>    Args:<br>        name: The name of the guardrail.<br>        triggered: Whether the guardrail was triggered.<br>        span_id: The ID of the span. Optional. If not provided, we will generate an ID. We<br>            recommend using `util.gen_span_id()` to generate a span ID, to guarantee that IDs are<br>            correctly formatted.<br>        parent: The parent span or trace. If not provided, we will automatically use the current<br>            trace/span as the parent.<br>        disabled: If True, we will return a Span but the Span will not be recorded.<br>    \"\"\"<br>    return get_trace_provider().create_span(<br>        span_data=GuardrailSpanData(name=name, triggered=triggered),<br>        span_id=span_id,<br>        parent=parent,<br>        disabled=disabled,<br>    )<br>``` |\n\n### handoff\\_span\n\n```md-code__content\nhandoff_span(\n    from_agent: str | None = None,\n    to_agent: str | None = None,\n    span_id: str | None = None,\n    parent: Trace | Span[Any] | None = None,\n    disabled: bool = False,\n) -> Span[HandoffSpanData]\n\n```\n\nCreate a new handoff span. The span will not be started automatically, you should either do\n`with handoff_span() ...` or call `span.start()` \\+ `span.finish()` manually.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `from_agent` | `str | None` | The name of the agent that is handing off. | `None` |\n| `to_agent` | `str | None` | The name of the agent that is receiving the handoff. | `None` |\n| `span_id` | `str | None` | The ID of the span. Optional. If not provided, we will generate an ID. We<br>recommend using `util.gen_span_id()` to generate a span ID, to guarantee that IDs are<br>correctly formatted. | `None` |\n| `parent` | `Trace | Span[Any] | None` | The parent span or trace. If not provided, we will automatically use the current<br>trace/span as the parent. | `None` |\n| `disabled` | `bool` | If True, we will return a Span but the Span will not be recorded. | `False` |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `Span[HandoffSpanData]` | The newly created handoff span. |\n\nSource code in `src/agents/tracing/create.py`\n\n|     |     |\n| --- | --- |\n| ```<br>226<br>227<br>228<br>229<br>230<br>231<br>232<br>233<br>234<br>235<br>236<br>237<br>238<br>239<br>240<br>241<br>242<br>243<br>244<br>245<br>246<br>247<br>248<br>249<br>250<br>251<br>252<br>253<br>254<br>``` | ```md-code__content<br>def handoff_span(<br>    from_agent: str | None = None,<br>    to_agent: str | None = None,<br>    span_id: str | None = None,<br>    parent: Trace | Span[Any] | None = None,<br>    disabled: bool = False,<br>) -> Span[HandoffSpanData]:<br>    \"\"\"Create a new handoff span. The span will not be started automatically, you should either do<br>    `with handoff_span() ...` or call `span.start()` + `span.finish()` manually.<br>    Args:<br>        from_agent: The name of the agent that is handing off.<br>        to_agent: The name of the agent that is receiving the handoff.<br>        span_id: The ID of the span. Optional. If not provided, we will generate an ID. We<br>            recommend using `util.gen_span_id()` to generate a span ID, to guarantee that IDs are<br>            correctly formatted.<br>        parent: The parent span or trace. If not provided, we will automatically use the current<br>            trace/span as the parent.<br>        disabled: If True, we will return a Span but the Span will not be recorded.<br>    Returns:<br>        The newly created handoff span.<br>    \"\"\"<br>    return get_trace_provider().create_span(<br>        span_data=HandoffSpanData(from_agent=from_agent, to_agent=to_agent),<br>        span_id=span_id,<br>        parent=parent,<br>        disabled=disabled,<br>    )<br>``` |\n\n### mcp\\_tools\\_span\n\n```md-code__content\nmcp_tools_span(\n    server: str | None = None,\n    result: list[str] | None = None,\n    span_id: str | None = None,\n    parent: Trace | Span[Any] | None = None,\n    disabled: bool = False,\n) -> Span[MCPListToolsSpanData]\n\n```\n\nCreate a new MCP list tools span. The span will not be started automatically, you should\neither do `with mcp_tools_span() ...` or call `span.start()` \\+ `span.finish()` manually.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `server` | `str | None` | The name of the MCP server. | `None` |\n| `result` | `list[str] | None` | The result of the MCP list tools call. | `None` |\n| `span_id` | `str | None` | The ID of the span. Optional. If not provided, we will generate an ID. We<br>recommend using `util.gen_span_id()` to generate a span ID, to guarantee that IDs are<br>correctly formatted. | `None` |\n| `parent` | `Trace | Span[Any] | None` | The parent span or trace. If not provided, we will automatically use the current<br>trace/span as the parent. | `None` |\n| `disabled` | `bool` | If True, we will return a Span but the Span will not be recorded. | `False` |\n\nSource code in `src/agents/tracing/create.py`\n\n|     |     |\n| --- | --- |\n| ```<br>430<br>431<br>432<br>433<br>434<br>435<br>436<br>437<br>438<br>439<br>440<br>441<br>442<br>443<br>444<br>445<br>446<br>447<br>448<br>449<br>450<br>451<br>452<br>453<br>454<br>455<br>``` | ```md-code__content<br>def mcp_tools_span(<br>    server: str | None = None,<br>    result: list[str] | None = None,<br>    span_id: str | None = None,<br>    parent: Trace | Span[Any] | None = None,<br>    disabled: bool = False,<br>) -> Span[MCPListToolsSpanData]:<br>    \"\"\"Create a new MCP list tools span. The span will not be started automatically, you should<br>    either do `with mcp_tools_span() ...` or call `span.start()` + `span.finish()` manually.<br>    Args:<br>        server: The name of the MCP server.<br>        result: The result of the MCP list tools call.<br>        span_id: The ID of the span. Optional. If not provided, we will generate an ID. We<br>            recommend using `util.gen_span_id()` to generate a span ID, to guarantee that IDs are<br>            correctly formatted.<br>        parent: The parent span or trace. If not provided, we will automatically use the current<br>            trace/span as the parent.<br>        disabled: If True, we will return a Span but the Span will not be recorded.<br>    \"\"\"<br>    return get_trace_provider().create_span(<br>        span_data=MCPListToolsSpanData(server=server, result=result),<br>        span_id=span_id,<br>        parent=parent,<br>        disabled=disabled,<br>    )<br>``` |\n\n### response\\_span\n\n```md-code__content\nresponse_span(\n    response: Response | None = None,\n    span_id: str | None = None,\n    parent: Trace | Span[Any] | None = None,\n    disabled: bool = False,\n) -> Span[ResponseSpanData]\n\n```\n\nCreate a new response span. The span will not be started automatically, you should either do\n`with response_span() ...` or call `span.start()` \\+ `span.finish()` manually.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `response` | `Response | None` | The OpenAI Response object. | `None` |\n| `span_id` | `str | None` | The ID of the span. Optional. If not provided, we will generate an ID. We<br>recommend using `util.gen_span_id()` to generate a span ID, to guarantee that IDs are<br>correctly formatted. | `None` |\n| `parent` | `Trace | Span[Any] | None` | The parent span or trace. If not provided, we will automatically use the current<br>trace/span as the parent. | `None` |\n| `disabled` | `bool` | If True, we will return a Span but the Span will not be recorded. | `False` |\n\nSource code in `src/agents/tracing/create.py`\n\n|     |     |\n| --- | --- |\n| ```<br>200<br>201<br>202<br>203<br>204<br>205<br>206<br>207<br>208<br>209<br>210<br>211<br>212<br>213<br>214<br>215<br>216<br>217<br>218<br>219<br>220<br>221<br>222<br>223<br>``` | ```md-code__content<br>def response_span(<br>    response: Response | None = None,<br>    span_id: str | None = None,<br>    parent: Trace | Span[Any] | None = None,<br>    disabled: bool = False,<br>) -> Span[ResponseSpanData]:<br>    \"\"\"Create a new response span. The span will not be started automatically, you should either do<br>    `with response_span() ...` or call `span.start()` + `span.finish()` manually.<br>    Args:<br>        response: The OpenAI Response object.<br>        span_id: The ID of the span. Optional. If not provided, we will generate an ID. We<br>            recommend using `util.gen_span_id()` to generate a span ID, to guarantee that IDs are<br>            correctly formatted.<br>        parent: The parent span or trace. If not provided, we will automatically use the current<br>            trace/span as the parent.<br>        disabled: If True, we will return a Span but the Span will not be recorded.<br>    \"\"\"<br>    return get_trace_provider().create_span(<br>        span_data=ResponseSpanData(response=response),<br>        span_id=span_id,<br>        parent=parent,<br>        disabled=disabled,<br>    )<br>``` |\n\n### speech\\_group\\_span\n\n```md-code__content\nspeech_group_span(\n    input: str | None = None,\n    span_id: str | None = None,\n    parent: Trace | Span[Any] | None = None,\n    disabled: bool = False,\n) -> Span[SpeechGroupSpanData]\n\n```\n\nCreate a new speech group span. The span will not be started automatically, you should\neither do `with speech_group_span() ...` or call `span.start()` \\+ `span.finish()` manually.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `input` | `str | None` | The input text used for the speech request. | `None` |\n| `span_id` | `str | None` | The ID of the span. Optional. If not provided, we will generate an ID. We<br>recommend using `util.gen_span_id()` to generate a span ID, to guarantee that IDs are<br>correctly formatted. | `None` |\n| `parent` | `Trace | Span[Any] | None` | The parent span or trace. If not provided, we will automatically use the current<br>trace/span as the parent. | `None` |\n| `disabled` | `bool` | If True, we will return a Span but the Span will not be recorded. | `False` |\n\nSource code in `src/agents/tracing/create.py`\n\n|     |     |\n| --- | --- |\n| ```<br>404<br>405<br>406<br>407<br>408<br>409<br>410<br>411<br>412<br>413<br>414<br>415<br>416<br>417<br>418<br>419<br>420<br>421<br>422<br>423<br>424<br>425<br>426<br>427<br>``` | ```md-code__content<br>def speech_group_span(<br>    input: str | None = None,<br>    span_id: str | None = None,<br>    parent: Trace | Span[Any] | None = None,<br>    disabled: bool = False,<br>) -> Span[SpeechGroupSpanData]:<br>    \"\"\"Create a new speech group span. The span will not be started automatically, you should<br>    either do `with speech_group_span() ...` or call `span.start()` + `span.finish()` manually.<br>    Args:<br>        input: The input text used for the speech request.<br>        span_id: The ID of the span. Optional. If not provided, we will generate an ID. We<br>            recommend using `util.gen_span_id()` to generate a span ID, to guarantee that IDs are<br>            correctly formatted.<br>        parent: The parent span or trace. If not provided, we will automatically use the current<br>            trace/span as the parent.<br>        disabled: If True, we will return a Span but the Span will not be recorded.<br>    \"\"\"<br>    return get_trace_provider().create_span(<br>        span_data=SpeechGroupSpanData(input=input),<br>        span_id=span_id,<br>        parent=parent,<br>        disabled=disabled,<br>    )<br>``` |\n\n### speech\\_span\n\n```md-code__content\nspeech_span(\n    model: str | None = None,\n    input: str | None = None,\n    output: str | None = None,\n    output_format: str | None = \"pcm\",\n    model_config: Mapping[str, Any] | None = None,\n    first_content_at: str | None = None,\n    span_id: str | None = None,\n    parent: Trace | Span[Any] | None = None,\n    disabled: bool = False,\n) -> Span[SpeechSpanData]\n\n```\n\nCreate a new speech span. The span will not be started automatically, you should either do\n`with speech_span() ...` or call `span.start()` \\+ `span.finish()` manually.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `model` | `str | None` | The name of the model used for the text-to-speech. | `None` |\n| `input` | `str | None` | The text input of the text-to-speech. | `None` |\n| `output` | `str | None` | The audio output of the text-to-speech as base64 encoded string of PCM audio bytes. | `None` |\n| `output_format` | `str | None` | The format of the audio output (defaults to \"pcm\"). | `'pcm'` |\n| `model_config` | `Mapping[str, Any] | None` | The model configuration (hyperparameters) used. | `None` |\n| `first_content_at` | `str | None` | The time of the first byte of the audio output. | `None` |\n| `span_id` | `str | None` | The ID of the span. Optional. If not provided, we will generate an ID. We<br>recommend using `util.gen_span_id()` to generate a span ID, to guarantee that IDs are<br>correctly formatted. | `None` |\n| `parent` | `Trace | Span[Any] | None` | The parent span or trace. If not provided, we will automatically use the current<br>trace/span as the parent. | `None` |\n| `disabled` | `bool` | If True, we will return a Span but the Span will not be recorded. | `False` |\n\nSource code in `src/agents/tracing/create.py`\n\n|     |     |\n| --- | --- |\n| ```<br>361<br>362<br>363<br>364<br>365<br>366<br>367<br>368<br>369<br>370<br>371<br>372<br>373<br>374<br>375<br>376<br>377<br>378<br>379<br>380<br>381<br>382<br>383<br>384<br>385<br>386<br>387<br>388<br>389<br>390<br>391<br>392<br>393<br>394<br>395<br>396<br>397<br>398<br>399<br>400<br>401<br>``` | ```md-code__content<br>def speech_span(<br>    model: str | None = None,<br>    input: str | None = None,<br>    output: str | None = None,<br>    output_format: str | None = \"pcm\",<br>    model_config: Mapping[str, Any] | None = None,<br>    first_content_at: str | None = None,<br>    span_id: str | None = None,<br>    parent: Trace | Span[Any] | None = None,<br>    disabled: bool = False,<br>) -> Span[SpeechSpanData]:<br>    \"\"\"Create a new speech span. The span will not be started automatically, you should either do<br>    `with speech_span() ...` or call `span.start()` + `span.finish()` manually.<br>    Args:<br>        model: The name of the model used for the text-to-speech.<br>        input: The text input of the text-to-speech.<br>        output: The audio output of the text-to-speech as base64 encoded string of PCM audio bytes.<br>        output_format: The format of the audio output (defaults to \"pcm\").<br>        model_config: The model configuration (hyperparameters) used.<br>        first_content_at: The time of the first byte of the audio output.<br>        span_id: The ID of the span. Optional. If not provided, we will generate an ID. We<br>            recommend using `util.gen_span_id()` to generate a span ID, to guarantee that IDs are<br>            correctly formatted.<br>        parent: The parent span or trace. If not provided, we will automatically use the current<br>            trace/span as the parent.<br>        disabled: If True, we will return a Span but the Span will not be recorded.<br>    \"\"\"<br>    return get_trace_provider().create_span(<br>        span_data=SpeechSpanData(<br>            model=model,<br>            input=input,<br>            output=output,<br>            output_format=output_format,<br>            model_config=model_config,<br>            first_content_at=first_content_at,<br>        ),<br>        span_id=span_id,<br>        parent=parent,<br>        disabled=disabled,<br>    )<br>``` |\n\n### trace\n\n```md-code__content\ntrace(\n    workflow_name: str,\n    trace_id: str | None = None,\n    group_id: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    disabled: bool = False,\n) -> Trace\n\n```\n\nCreate a new trace. The trace will not be started automatically; you should either use\nit as a context manager ( `with trace(...):`) or call `trace.start()` \\+ `trace.finish()`\nmanually.\n\nIn addition to the workflow name and optional grouping identifier, you can provide\nan arbitrary metadata dictionary to attach additional user-defined information to\nthe trace.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `workflow_name` | `str` | The name of the logical app or workflow. For example, you might provide<br>\"code\\_bot\" for a coding agent, or \"customer\\_support\\_agent\" for a customer support agent. | _required_ |\n| `trace_id` | `str | None` | The ID of the trace. Optional. If not provided, we will generate an ID. We<br>recommend using `util.gen_trace_id()` to generate a trace ID, to guarantee that IDs are<br>correctly formatted. | `None` |\n| `group_id` | `str | None` | Optional grouping identifier to link multiple traces from the same conversation<br>or process. For instance, you might use a chat thread ID. | `None` |\n| `metadata` | `dict[str, Any] | None` | Optional dictionary of additional metadata to attach to the trace. | `None` |\n| `disabled` | `bool` | If True, we will return a Trace but the Trace will not be recorded. This will<br>not be checked if there's an existing trace and `even_if_trace_running` is True. | `False` |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `Trace` | The newly created trace object. |\n\nSource code in `src/agents/tracing/create.py`\n\n|     |     |\n| --- | --- |\n| ```<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>``` | ```md-code__content<br>def trace(<br>    workflow_name: str,<br>    trace_id: str | None = None,<br>    group_id: str | None = None,<br>    metadata: dict[str, Any] | None = None,<br>    disabled: bool = False,<br>) -> Trace:<br>    \"\"\"<br>    Create a new trace. The trace will not be started automatically; you should either use<br>    it as a context manager (`with trace(...):`) or call `trace.start()` + `trace.finish()`<br>    manually.<br>    In addition to the workflow name and optional grouping identifier, you can provide<br>    an arbitrary metadata dictionary to attach additional user-defined information to<br>    the trace.<br>    Args:<br>        workflow_name: The name of the logical app or workflow. For example, you might provide<br>            \"code_bot\" for a coding agent, or \"customer_support_agent\" for a customer support agent.<br>        trace_id: The ID of the trace. Optional. If not provided, we will generate an ID. We<br>            recommend using `util.gen_trace_id()` to generate a trace ID, to guarantee that IDs are<br>            correctly formatted.<br>        group_id: Optional grouping identifier to link multiple traces from the same conversation<br>            or process. For instance, you might use a chat thread ID.<br>        metadata: Optional dictionary of additional metadata to attach to the trace.<br>        disabled: If True, we will return a Trace but the Trace will not be recorded. This will<br>            not be checked if there's an existing trace and `even_if_trace_running` is True.<br>    Returns:<br>        The newly created trace object.<br>    \"\"\"<br>    current_trace = get_trace_provider().get_current_trace()<br>    if current_trace:<br>        logger.warning(<br>            \"Trace already exists. Creating a new trace, but this is probably a mistake.\"<br>        )<br>    return get_trace_provider().create_trace(<br>        name=workflow_name,<br>        trace_id=trace_id,<br>        group_id=group_id,<br>        metadata=metadata,<br>        disabled=disabled,<br>    )<br>``` |\n\n### transcription\\_span\n\n```md-code__content\ntranscription_span(\n    model: str | None = None,\n    input: str | None = None,\n    input_format: str | None = \"pcm\",\n    output: str | None = None,\n    model_config: Mapping[str, Any] | None = None,\n    span_id: str | None = None,\n    parent: Trace | Span[Any] | None = None,\n    disabled: bool = False,\n) -> Span[TranscriptionSpanData]\n\n```\n\nCreate a new transcription span. The span will not be started automatically, you should\neither do `with transcription_span() ...` or call `span.start()` \\+ `span.finish()` manually.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `model` | `str | None` | The name of the model used for the speech-to-text. | `None` |\n| `input` | `str | None` | The audio input of the speech-to-text transcription, as a base64 encoded string of<br>audio bytes. | `None` |\n| `input_format` | `str | None` | The format of the audio input (defaults to \"pcm\"). | `'pcm'` |\n| `output` | `str | None` | The output of the speech-to-text transcription. | `None` |\n| `model_config` | `Mapping[str, Any] | None` | The model configuration (hyperparameters) used. | `None` |\n| `span_id` | `str | None` | The ID of the span. Optional. If not provided, we will generate an ID. We<br>recommend using `util.gen_span_id()` to generate a span ID, to guarantee that IDs are<br>correctly formatted. | `None` |\n| `parent` | `Trace | Span[Any] | None` | The parent span or trace. If not provided, we will automatically use the current<br>trace/span as the parent. | `None` |\n| `disabled` | `bool` | If True, we will return a Span but the Span will not be recorded. | `False` |\n\nReturns:\n\n| Type | Description |\n| --- | --- |\n| `Span[TranscriptionSpanData]` | The newly created speech-to-text span. |\n\nSource code in `src/agents/tracing/create.py`\n\n|     |     |\n| --- | --- |\n| ```<br>317<br>318<br>319<br>320<br>321<br>322<br>323<br>324<br>325<br>326<br>327<br>328<br>329<br>330<br>331<br>332<br>333<br>334<br>335<br>336<br>337<br>338<br>339<br>340<br>341<br>342<br>343<br>344<br>345<br>346<br>347<br>348<br>349<br>350<br>351<br>352<br>353<br>354<br>355<br>356<br>357<br>358<br>``` | ```md-code__content<br>def transcription_span(<br>    model: str | None = None,<br>    input: str | None = None,<br>    input_format: str | None = \"pcm\",<br>    output: str | None = None,<br>    model_config: Mapping[str, Any] | None = None,<br>    span_id: str | None = None,<br>    parent: Trace | Span[Any] | None = None,<br>    disabled: bool = False,<br>) -> Span[TranscriptionSpanData]:<br>    \"\"\"Create a new transcription span. The span will not be started automatically, you should<br>    either do `with transcription_span() ...` or call `span.start()` + `span.finish()` manually.<br>    Args:<br>        model: The name of the model used for the speech-to-text.<br>        input: The audio input of the speech-to-text transcription, as a base64 encoded string of<br>            audio bytes.<br>        input_format: The format of the audio input (defaults to \"pcm\").<br>        output: The output of the speech-to-text transcription.<br>        model_config: The model configuration (hyperparameters) used.<br>        span_id: The ID of the span. Optional. If not provided, we will generate an ID. We<br>            recommend using `util.gen_span_id()` to generate a span ID, to guarantee that IDs are<br>            correctly formatted.<br>        parent: The parent span or trace. If not provided, we will automatically use the current<br>            trace/span as the parent.<br>        disabled: If True, we will return a Span but the Span will not be recorded.<br>    Returns:<br>        The newly created speech-to-text span.<br>    \"\"\"<br>    return get_trace_provider().create_span(<br>        span_data=TranscriptionSpanData(<br>            input=input,<br>            input_format=input_format,<br>            output=output,<br>            model=model,<br>            model_config=model_config,<br>        ),<br>        span_id=span_id,<br>        parent=parent,<br>        disabled=disabled,<br>    )<br>``` |\n\n### get\\_trace\\_provider\n\n```md-code__content\nget_trace_provider() -> TraceProvider\n\n```\n\nGet the global trace provider used by tracing utilities.\n\nSource code in `src/agents/tracing/setup.py`\n\n|     |     |\n| --- | --- |\n| ```<br>17<br>18<br>19<br>20<br>21<br>``` | ```md-code__content<br>def get_trace_provider() -> TraceProvider:<br>    \"\"\"Get the global trace provider used by tracing utilities.\"\"\"<br>    if GLOBAL_TRACE_PROVIDER is None:<br>        raise RuntimeError(\"Trace provider not set\")<br>    return GLOBAL_TRACE_PROVIDER<br>``` |\n\n### set\\_trace\\_provider\n\n```md-code__content\nset_trace_provider(provider: TraceProvider) -> None\n\n```\n\nSet the global trace provider used by tracing utilities.\n\nSource code in `src/agents/tracing/setup.py`\n\n|     |     |\n| --- | --- |\n| ```<br>11<br>12<br>13<br>14<br>``` | ```md-code__content<br>def set_trace_provider(provider: TraceProvider) -> None:<br>    \"\"\"Set the global trace provider used by tracing utilities.\"\"\"<br>    global GLOBAL_TRACE_PROVIDER<br>    GLOBAL_TRACE_PROVIDER = provider<br>``` |\n\n### gen\\_span\\_id\n\n```md-code__content\ngen_span_id() -> str\n\n```\n\nGenerate a new span ID.\n\nSource code in `src/agents/tracing/util.py`\n\n|     |     |\n| --- | --- |\n| ```<br>14<br>15<br>16<br>``` | ```md-code__content<br>def gen_span_id() -> str:<br>    \"\"\"Generate a new span ID.\"\"\"<br>    return get_trace_provider().gen_span_id()<br>``` |\n\n### gen\\_trace\\_id\n\n```md-code__content\ngen_trace_id() -> str\n\n```\n\nGenerate a new trace ID.\n\nSource code in `src/agents/tracing/util.py`\n\n|     |     |\n| --- | --- |\n| ```<br> 9<br>10<br>11<br>``` | ```md-code__content<br>def gen_trace_id() -> str:<br>    \"\"\"Generate a new trace ID.\"\"\"<br>    return get_trace_provider().gen_trace_id()<br>``` |\n\n### add\\_trace\\_processor\n\n```md-code__content\nadd_trace_processor(\n    span_processor: TracingProcessor,\n) -> None\n\n```\n\nAdds a new trace processor. This processor will receive all traces/spans.\n\nSource code in `src/agents/tracing/__init__.py`\n\n|     |     |\n| --- | --- |\n| ```<br>84<br>85<br>86<br>87<br>88<br>``` | ```md-code__content<br>def add_trace_processor(span_processor: TracingProcessor) -> None:<br>    \"\"\"<br>    Adds a new trace processor. This processor will receive all traces/spans.<br>    \"\"\"<br>    get_trace_provider().register_processor(span_processor)<br>``` |\n\n### set\\_trace\\_processors\n\n```md-code__content\nset_trace_processors(\n    processors: list[TracingProcessor],\n) -> None\n\n```\n\nSet the list of trace processors. This will replace the current list of processors.\n\nSource code in `src/agents/tracing/__init__.py`\n\n|     |     |\n| --- | --- |\n| ```<br>91<br>92<br>93<br>94<br>95<br>``` | ```md-code__content<br>def set_trace_processors(processors: list[TracingProcessor]) -> None:<br>    \"\"\"<br>    Set the list of trace processors. This will replace the current list of processors.<br>    \"\"\"<br>    get_trace_provider().set_processors(processors)<br>``` |\n\n### set\\_tracing\\_disabled\n\n```md-code__content\nset_tracing_disabled(disabled: bool) -> None\n\n```\n\nSet whether tracing is globally disabled.\n\nSource code in `src/agents/tracing/__init__.py`\n\n|     |     |\n| --- | --- |\n| ```<br> 98<br> 99<br>100<br>101<br>102<br>``` | ```md-code__content<br>def set_tracing_disabled(disabled: bool) -> None:<br>    \"\"\"<br>    Set whether tracing is globally disabled.<br>    \"\"\"<br>    get_trace_provider().set_disabled(disabled)<br>``` |\n\n### set\\_tracing\\_export\\_api\\_key\n\n```md-code__content\nset_tracing_export_api_key(api_key: str) -> None\n\n```\n\nSet the OpenAI API key for the backend exporter.\n\nSource code in `src/agents/tracing/__init__.py`\n\n|     |     |\n| --- | --- |\n| ```<br>105<br>106<br>107<br>108<br>109<br>``` | ```md-code__content<br>def set_tracing_export_api_key(api_key: str) -> None:<br>    \"\"\"<br>    Set the OpenAI API key for the backend exporter.<br>    \"\"\"<br>    default_exporter().set_api_key(api_key)<br>``` |",
  "metadata": {
    "language": "ja",
    "favicon": "https://openai.github.io/openai-agents-python/images/favicon-platform.svg",
    "viewport": "width=device-width,initial-scale=1",
    "title": "Tracing module - OpenAI Agents SDK",
    "generator": "mkdocs-1.6.1, mkdocs-material-9.6.11",
    "scrapeId": "76e982c5-f893-4314-9a62-a4ed2c807d78",
    "sourceURL": "https://openai.github.io/openai-agents-python/ja/ref/tracing/",
    "url": "https://openai.github.io/openai-agents-python/ja/ref/tracing/",
    "statusCode": 200,
    "contentType": "text/html; charset=utf-8",
    "proxyUsed": "basic"
  }
}