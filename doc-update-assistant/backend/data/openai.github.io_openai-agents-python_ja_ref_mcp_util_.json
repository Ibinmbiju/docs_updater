{
  "markdown": "[コンテンツにスキップ](https://openai.github.io/openai-agents-python/ja/ref/mcp/util/#mcp-util)\n\n# `MCP Util`\n\n### MCPUtil\n\nSet of utilities for interop between MCP and Agents SDK tools.\n\nSource code in `src/agents/mcp/util.py`\n\n|     |     |\n| --- | --- |\n| ```<br> 20<br> 21<br> 22<br> 23<br> 24<br> 25<br> 26<br> 27<br> 28<br> 29<br> 30<br> 31<br> 32<br> 33<br> 34<br> 35<br> 36<br> 37<br> 38<br> 39<br> 40<br> 41<br> 42<br> 43<br> 44<br> 45<br> 46<br> 47<br> 48<br> 49<br> 50<br> 51<br> 52<br> 53<br> 54<br> 55<br> 56<br> 57<br> 58<br> 59<br> 60<br> 61<br> 62<br> 63<br> 64<br> 65<br> 66<br> 67<br> 68<br> 69<br> 70<br> 71<br> 72<br> 73<br> 74<br> 75<br> 76<br> 77<br> 78<br> 79<br> 80<br> 81<br> 82<br> 83<br> 84<br> 85<br> 86<br> 87<br> 88<br> 89<br> 90<br> 91<br> 92<br> 93<br> 94<br> 95<br> 96<br> 97<br> 98<br> 99<br>100<br>101<br>102<br>103<br>104<br>105<br>106<br>107<br>108<br>109<br>110<br>111<br>112<br>113<br>114<br>115<br>116<br>117<br>118<br>119<br>120<br>121<br>122<br>123<br>124<br>125<br>126<br>127<br>128<br>129<br>130<br>131<br>132<br>133<br>134<br>135<br>136<br>``` | ```md-code__content<br>class MCPUtil:<br>    \"\"\"Set of utilities for interop between MCP and Agents SDK tools.\"\"\"<br>    @classmethod<br>    async def get_all_function_tools(<br>        cls, servers: list[\"MCPServer\"], convert_schemas_to_strict: bool<br>    ) -> list[Tool]:<br>        \"\"\"Get all function tools from a list of MCP servers.\"\"\"<br>        tools = []<br>        tool_names: set[str] = set()<br>        for server in servers:<br>            server_tools = await cls.get_function_tools(server, convert_schemas_to_strict)<br>            server_tool_names = {tool.name for tool in server_tools}<br>            if len(server_tool_names & tool_names) > 0:<br>                raise UserError(<br>                    f\"Duplicate tool names found across MCP servers: \"<br>                    f\"{server_tool_names & tool_names}\"<br>                )<br>            tool_names.update(server_tool_names)<br>            tools.extend(server_tools)<br>        return tools<br>    @classmethod<br>    async def get_function_tools(<br>        cls, server: \"MCPServer\", convert_schemas_to_strict: bool<br>    ) -> list[Tool]:<br>        \"\"\"Get all function tools from a single MCP server.\"\"\"<br>        with mcp_tools_span(server=server.name) as span:<br>            tools = await server.list_tools()<br>            span.span_data.result = [tool.name for tool in tools]<br>        return [cls.to_function_tool(tool, server, convert_schemas_to_strict) for tool in tools]<br>    @classmethod<br>    def to_function_tool(<br>        cls, tool: \"MCPTool\", server: \"MCPServer\", convert_schemas_to_strict: bool<br>    ) -> FunctionTool:<br>        \"\"\"Convert an MCP tool to an Agents SDK function tool.\"\"\"<br>        invoke_func = functools.partial(cls.invoke_mcp_tool, server, tool)<br>        schema, is_strict = tool.inputSchema, False<br>        # MCP spec doesn't require the inputSchema to have `properties`, but OpenAI spec does.<br>        if \"properties\" not in schema:<br>            schema[\"properties\"] = {}<br>        if convert_schemas_to_strict:<br>            try:<br>                schema = ensure_strict_json_schema(schema)<br>                is_strict = True<br>            except Exception as e:<br>                logger.info(f\"Error converting MCP schema to strict mode: {e}\")<br>        return FunctionTool(<br>            name=tool.name,<br>            description=tool.description or \"\",<br>            params_json_schema=schema,<br>            on_invoke_tool=invoke_func,<br>            strict_json_schema=is_strict,<br>        )<br>    @classmethod<br>    async def invoke_mcp_tool(<br>        cls, server: \"MCPServer\", tool: \"MCPTool\", context: RunContextWrapper[Any], input_json: str<br>    ) -> str:<br>        \"\"\"Invoke an MCP tool and return the result as a string.\"\"\"<br>        try:<br>            json_data: dict[str, Any] = json.loads(input_json) if input_json else {}<br>        except Exception as e:<br>            if _debug.DONT_LOG_TOOL_DATA:<br>                logger.debug(f\"Invalid JSON input for tool {tool.name}\")<br>            else:<br>                logger.debug(f\"Invalid JSON input for tool {tool.name}: {input_json}\")<br>            raise ModelBehaviorError(<br>                f\"Invalid JSON input for tool {tool.name}: {input_json}\"<br>            ) from e<br>        if _debug.DONT_LOG_TOOL_DATA:<br>            logger.debug(f\"Invoking MCP tool {tool.name}\")<br>        else:<br>            logger.debug(f\"Invoking MCP tool {tool.name} with input {input_json}\")<br>        try:<br>            result = await server.call_tool(tool.name, json_data)<br>        except Exception as e:<br>            logger.error(f\"Error invoking MCP tool {tool.name}: {e}\")<br>            raise AgentsException(f\"Error invoking MCP tool {tool.name}: {e}\") from e<br>        if _debug.DONT_LOG_TOOL_DATA:<br>            logger.debug(f\"MCP tool {tool.name} completed.\")<br>        else:<br>            logger.debug(f\"MCP tool {tool.name} returned {result}\")<br>        # The MCP tool result is a list of content items, whereas OpenAI tool outputs are a single<br>        # string. We'll try to convert.<br>        if len(result.content) == 1:<br>            tool_output = result.content[0].model_dump_json()<br>        elif len(result.content) > 1:<br>            tool_output = json.dumps([item.model_dump(mode=\"json\") for item in result.content])<br>        else:<br>            logger.error(f\"Errored MCP tool result: {result}\")<br>            tool_output = \"Error running tool.\"<br>        current_span = get_current_span()<br>        if current_span:<br>            if isinstance(current_span.span_data, FunctionSpanData):<br>                current_span.span_data.output = tool_output<br>                current_span.span_data.mcp_data = {<br>                    \"server\": server.name,<br>                }<br>            else:<br>                logger.warning(<br>                    f\"Current span is not a FunctionSpanData, skipping tool output: {current_span}\"<br>                )<br>        return tool_output<br>``` |\n\n#### get\\_all\\_function\\_tools`async``classmethod`\n\n```md-code__content\nget_all_function_tools(\n    servers: list[MCPServer],\n    convert_schemas_to_strict: bool,\n) -> list[Tool]\n\n```\n\nGet all function tools from a list of MCP servers.\n\nSource code in `src/agents/mcp/util.py`\n\n|     |     |\n| --- | --- |\n| ```<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>``` | ```md-code__content<br>@classmethod<br>async def get_all_function_tools(<br>    cls, servers: list[\"MCPServer\"], convert_schemas_to_strict: bool<br>) -> list[Tool]:<br>    \"\"\"Get all function tools from a list of MCP servers.\"\"\"<br>    tools = []<br>    tool_names: set[str] = set()<br>    for server in servers:<br>        server_tools = await cls.get_function_tools(server, convert_schemas_to_strict)<br>        server_tool_names = {tool.name for tool in server_tools}<br>        if len(server_tool_names & tool_names) > 0:<br>            raise UserError(<br>                f\"Duplicate tool names found across MCP servers: \"<br>                f\"{server_tool_names & tool_names}\"<br>            )<br>        tool_names.update(server_tool_names)<br>        tools.extend(server_tools)<br>    return tools<br>``` |\n\n#### get\\_function\\_tools`async``classmethod`\n\n```md-code__content\nget_function_tools(\n    server: MCPServer, convert_schemas_to_strict: bool\n) -> list[Tool]\n\n```\n\nGet all function tools from a single MCP server.\n\nSource code in `src/agents/mcp/util.py`\n\n|     |     |\n| --- | --- |\n| ```<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>``` | ```md-code__content<br>@classmethod<br>async def get_function_tools(<br>    cls, server: \"MCPServer\", convert_schemas_to_strict: bool<br>) -> list[Tool]:<br>    \"\"\"Get all function tools from a single MCP server.\"\"\"<br>    with mcp_tools_span(server=server.name) as span:<br>        tools = await server.list_tools()<br>        span.span_data.result = [tool.name for tool in tools]<br>    return [cls.to_function_tool(tool, server, convert_schemas_to_strict) for tool in tools]<br>``` |\n\n#### to\\_function\\_tool`classmethod`\n\n```md-code__content\nto_function_tool(\n    tool: Tool,\n    server: MCPServer,\n    convert_schemas_to_strict: bool,\n) -> FunctionTool\n\n```\n\nConvert an MCP tool to an Agents SDK function tool.\n\nSource code in `src/agents/mcp/util.py`\n\n|     |     |\n| --- | --- |\n| ```<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>72<br>73<br>74<br>75<br>76<br>77<br>78<br>79<br>80<br>``` | ```md-code__content<br>@classmethod<br>def to_function_tool(<br>    cls, tool: \"MCPTool\", server: \"MCPServer\", convert_schemas_to_strict: bool<br>) -> FunctionTool:<br>    \"\"\"Convert an MCP tool to an Agents SDK function tool.\"\"\"<br>    invoke_func = functools.partial(cls.invoke_mcp_tool, server, tool)<br>    schema, is_strict = tool.inputSchema, False<br>    # MCP spec doesn't require the inputSchema to have `properties`, but OpenAI spec does.<br>    if \"properties\" not in schema:<br>        schema[\"properties\"] = {}<br>    if convert_schemas_to_strict:<br>        try:<br>            schema = ensure_strict_json_schema(schema)<br>            is_strict = True<br>        except Exception as e:<br>            logger.info(f\"Error converting MCP schema to strict mode: {e}\")<br>    return FunctionTool(<br>        name=tool.name,<br>        description=tool.description or \"\",<br>        params_json_schema=schema,<br>        on_invoke_tool=invoke_func,<br>        strict_json_schema=is_strict,<br>    )<br>``` |\n\n#### invoke\\_mcp\\_tool`async``classmethod`\n\n```md-code__content\ninvoke_mcp_tool(\n    server: MCPServer,\n    tool: Tool,\n    context: RunContextWrapper[Any],\n    input_json: str,\n) -> str\n\n```\n\nInvoke an MCP tool and return the result as a string.\n\nSource code in `src/agents/mcp/util.py`\n\n|     |     |\n| --- | --- |\n| ```<br> 82<br> 83<br> 84<br> 85<br> 86<br> 87<br> 88<br> 89<br> 90<br> 91<br> 92<br> 93<br> 94<br> 95<br> 96<br> 97<br> 98<br> 99<br>100<br>101<br>102<br>103<br>104<br>105<br>106<br>107<br>108<br>109<br>110<br>111<br>112<br>113<br>114<br>115<br>116<br>117<br>118<br>119<br>120<br>121<br>122<br>123<br>124<br>125<br>126<br>127<br>128<br>129<br>130<br>131<br>132<br>133<br>134<br>135<br>136<br>``` | ```md-code__content<br>@classmethod<br>async def invoke_mcp_tool(<br>    cls, server: \"MCPServer\", tool: \"MCPTool\", context: RunContextWrapper[Any], input_json: str<br>) -> str:<br>    \"\"\"Invoke an MCP tool and return the result as a string.\"\"\"<br>    try:<br>        json_data: dict[str, Any] = json.loads(input_json) if input_json else {}<br>    except Exception as e:<br>        if _debug.DONT_LOG_TOOL_DATA:<br>            logger.debug(f\"Invalid JSON input for tool {tool.name}\")<br>        else:<br>            logger.debug(f\"Invalid JSON input for tool {tool.name}: {input_json}\")<br>        raise ModelBehaviorError(<br>            f\"Invalid JSON input for tool {tool.name}: {input_json}\"<br>        ) from e<br>    if _debug.DONT_LOG_TOOL_DATA:<br>        logger.debug(f\"Invoking MCP tool {tool.name}\")<br>    else:<br>        logger.debug(f\"Invoking MCP tool {tool.name} with input {input_json}\")<br>    try:<br>        result = await server.call_tool(tool.name, json_data)<br>    except Exception as e:<br>        logger.error(f\"Error invoking MCP tool {tool.name}: {e}\")<br>        raise AgentsException(f\"Error invoking MCP tool {tool.name}: {e}\") from e<br>    if _debug.DONT_LOG_TOOL_DATA:<br>        logger.debug(f\"MCP tool {tool.name} completed.\")<br>    else:<br>        logger.debug(f\"MCP tool {tool.name} returned {result}\")<br>    # The MCP tool result is a list of content items, whereas OpenAI tool outputs are a single<br>    # string. We'll try to convert.<br>    if len(result.content) == 1:<br>        tool_output = result.content[0].model_dump_json()<br>    elif len(result.content) > 1:<br>        tool_output = json.dumps([item.model_dump(mode=\"json\") for item in result.content])<br>    else:<br>        logger.error(f\"Errored MCP tool result: {result}\")<br>        tool_output = \"Error running tool.\"<br>    current_span = get_current_span()<br>    if current_span:<br>        if isinstance(current_span.span_data, FunctionSpanData):<br>            current_span.span_data.output = tool_output<br>            current_span.span_data.mcp_data = {<br>                \"server\": server.name,<br>            }<br>        else:<br>            logger.warning(<br>                f\"Current span is not a FunctionSpanData, skipping tool output: {current_span}\"<br>            )<br>    return tool_output<br>``` |",
  "metadata": {
    "generator": "mkdocs-1.6.1, mkdocs-material-9.6.11",
    "language": "ja",
    "viewport": "width=device-width,initial-scale=1",
    "title": "MCP Util - OpenAI Agents SDK",
    "favicon": "https://openai.github.io/openai-agents-python/images/favicon-platform.svg",
    "scrapeId": "5dac1036-df30-4198-9d76-41366205b74c",
    "sourceURL": "https://openai.github.io/openai-agents-python/ja/ref/mcp/util/",
    "url": "https://openai.github.io/openai-agents-python/ja/ref/mcp/util/",
    "statusCode": 200,
    "contentType": "text/html; charset=utf-8",
    "proxyUsed": "basic"
  },
  "warning": "This scrape job was throttled at your current concurrency limit. If you'd like to scrape faster, you can upgrade your plan."
}