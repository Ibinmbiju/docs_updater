{
  "markdown": "[コンテンツにスキップ](https://openai.github.io/openai-agents-python/ja/agents/#_1)\n\n# エージェント\n\nエージェントはアプリの主要な構成ブロックです。エージェントは、大規模言語モデル ( LLM ) に instructions と tools を設定したものです。\n\n## 基本設定\n\nエージェントで最も一般的に設定するプロパティは次のとおりです。\n\n- `instructions`: 開発者メッセージまたは system prompt とも呼ばれます。\n- `model`: 使用する LLM と、temperature や top\\_p などのモデル調整パラメーターを指定する任意の `model_settings`。\n- `tools`: エージェントがタスクを達成するために利用できるツール。\n\n```md-code__content\nfrom agents import Agent, ModelSettings, function_tool\n\n@function_tool\ndef get_weather(city: str) -> str:\n    return f\"The weather in {city} is sunny\"\n\nagent = Agent(\n    name=\"Haiku agent\",\n    instructions=\"Always respond in haiku form\",\n    model=\"o3-mini\",\n    tools=[get_weather],\n)\n\n```\n\n## コンテキスト\n\nエージェントはその `context` 型について汎用的です。コンテキストは依存性注入の手段で、 `Runner.run()` に渡すオブジェクトです。これはすべてのエージェント、ツール、ハンドオフなどに渡され、エージェント実行時の依存関係や状態をまとめて保持します。任意の Python オブジェクトをコンテキストとして渡せます。\n\n```md-code__content\n@dataclass\nclass UserContext:\n    uid: str\n    is_pro_user: bool\n\n    async def fetch_purchases() -> list[Purchase]:\n        return ...\n\nagent = Agent[UserContext](\n    ...,\n)\n\n```\n\n## 出力タイプ\n\nデフォルトでは、エージェントはプレーンテキスト ( つまり `str` ) を出力します。特定の型で出力させたい場合は `output_type` パラメーターを使用します。一般的には [Pydantic](https://docs.pydantic.dev/) オブジェクトを利用しますが、Pydantic の [TypeAdapter](https://docs.pydantic.dev/latest/api/type_adapter/) でラップ可能な型であれば何でも対応します。たとえば dataclass、list、TypedDict などです。\n\n```md-code__content\nfrom pydantic import BaseModel\nfrom agents import Agent\n\nclass CalendarEvent(BaseModel):\n    name: str\n    date: str\n    participants: list[str]\n\nagent = Agent(\n    name=\"Calendar extractor\",\n    instructions=\"Extract calendar events from text\",\n    output_type=CalendarEvent,\n)\n\n```\n\nNote\n\n`output_type` を渡すと、モデルは通常のプレーンテキスト応答の代わりに [structured outputs](https://platform.openai.com/docs/guides/structured-outputs) を使用するよう指示されます。\n\n## ハンドオフ\n\nハンドオフは、エージェントが委譲できるサブエージェントです。ハンドオフのリストを渡しておくと、エージェントは必要に応じてそれらに処理を委譲できます。これにより、単一のタスクに特化したモジュール式エージェントを編成できる強力なパターンが実現します。詳細は [handoffs](https://openai.github.io/openai-agents-python/ja/handoffs/) ドキュメントをご覧ください。\n\n```md-code__content\nfrom agents import Agent\n\nbooking_agent = Agent(...)\nrefund_agent = Agent(...)\n\ntriage_agent = Agent(\n    name=\"Triage agent\",\n    instructions=(\n        \"Help the user with their questions.\"\n        \"If they ask about booking, handoff to the booking agent.\"\n        \"If they ask about refunds, handoff to the refund agent.\"\n    ),\n    handoffs=[booking_agent, refund_agent],\n)\n\n```\n\n## 動的 instructions\n\n通常はエージェント作成時に instructions を指定しますが、関数を介して動的に instructions を提供することもできます。その関数はエージェントとコンテキストを受け取り、プロンプトを返す必要があります。同期関数と `async` 関数の両方に対応しています。\n\n```md-code__content\ndef dynamic_instructions(\n    context: RunContextWrapper[UserContext], agent: Agent[UserContext]\n) -> str:\n    return f\"The user's name is {context.context.name}. Help them with their questions.\"\n\nagent = Agent[UserContext](\n    name=\"Triage agent\",\n    instructions=dynamic_instructions,\n)\n\n```\n\n## ライフサイクルイベント (hooks)\n\n場合によっては、エージェントのライフサイクルを観察したいことがあります。たとえば、イベントをログに記録したり、特定のイベント発生時にデータを事前取得したりする場合です。 `hooks` プロパティを使ってエージェントのライフサイクルにフックできます。 [`AgentHooks`](https://openai.github.io/openai-agents-python/ref/lifecycle/#agents.lifecycle.AgentHooks \"AgentHooks\") クラスをサブクラス化し、関心のあるメソッドをオーバーライドしてください。\n\n## ガードレール\n\nガードレールを使うと、エージェントの実行と並行してユーザー入力に対するチェックやバリデーションを実行できます。たとえば、ユーザーの入力内容が関連しているかをスクリーニングできます。詳細は [guardrails](https://openai.github.io/openai-agents-python/ja/guardrails/) ドキュメントをご覧ください。\n\n## エージェントの複製\n\n`clone()` メソッドを使用すると、エージェントを複製し、必要に応じて任意のプロパティを変更できます。\n\n```md-code__content\npirate_agent = Agent(\n    name=\"Pirate\",\n    instructions=\"Write like a pirate\",\n    model=\"o3-mini\",\n)\n\nrobot_agent = pirate_agent.clone(\n    name=\"Robot\",\n    instructions=\"Write like a robot\",\n)\n\n```\n\n## ツール使用の強制\n\nツールの一覧を渡しても、LLM が必ずツールを使用するとは限りません。 [`ModelSettings.tool_choice`](https://openai.github.io/openai-agents-python/ref/model_settings/#agents.model_settings.ModelSettings.tool_choice \"tool_choice            class-attribute       instance-attribute   \") を設定することでツール使用を強制できます。有効な値は次のとおりです。\n\n1. `auto` — ツールを使用するかどうかを LLM が判断します。\n2. `required` — LLM にツール使用を必須化します ( ただし使用するツールは自動選択 )。\n3. `none` — LLM にツールを使用しないことを要求します。\n4. 特定の文字列 ( 例: `my_tool` ) — その特定のツールを LLM に使用させます。\n\nNote\n\n無限ループを防ぐため、フレームワークはツール呼び出し後に `tool_choice` を自動的に \"auto\" にリセットします。この動作は [`agent.reset_tool_choice`](https://openai.github.io/openai-agents-python/ref/agent/#agents.agent.Agent.reset_tool_choice \"reset_tool_choice            class-attribute       instance-attribute   \") で設定できます。無限ループが起こる理由は、ツールの結果が LLM に送られ、 `tool_choice` により再びツール呼び出しが生成される、という流れが繰り返されるからです。\n\nツール呼び出し後にエージェントを完全に停止させたい場合 ( auto モードで続行させたくない場合 ) は、\\[ `Agent.tool_use_behavior=\"stop_on_first_tool\"`\\] を設定してください。これにより、ツールの出力を LL M の追加処理なしにそのまま最終応答として返します。",
  "metadata": {
    "language": "ja",
    "favicon": "https://openai.github.io/openai-agents-python/images/favicon-platform.svg",
    "viewport": "width=device-width,initial-scale=1",
    "generator": "mkdocs-1.6.1, mkdocs-material-9.6.11",
    "title": "エージェント - OpenAI Agents SDK",
    "scrapeId": "f5eb1ec5-06c6-4515-a048-5c59045bbc39",
    "sourceURL": "https://openai.github.io/openai-agents-python/ja/agents/",
    "url": "https://openai.github.io/openai-agents-python/ja/agents/",
    "statusCode": 200,
    "contentType": "text/html; charset=utf-8",
    "proxyUsed": "basic"
  }
}