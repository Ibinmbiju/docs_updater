{
  "markdown": "[Skip to content](https://openai.github.io/openai-agents-python/ref/mcp/server/#mcp-servers)\n\n# `MCP Servers`\n\n### MCPServer\n\nBases: `ABC`\n\nBase class for Model Context Protocol servers.\n\nSource code in `src/agents/mcp/server.py`\n\n|     |     |\n| --- | --- |\n| ```<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>``` | ```md-code__content<br>class MCPServer(abc.ABC):<br>    \"\"\"Base class for Model Context Protocol servers.\"\"\"<br>    @abc.abstractmethod<br>    async def connect(self):<br>        \"\"\"Connect to the server. For example, this might mean spawning a subprocess or<br>        opening a network connection. The server is expected to remain connected until<br>        `cleanup()` is called.<br>        \"\"\"<br>        pass<br>    @property<br>    @abc.abstractmethod<br>    def name(self) -> str:<br>        \"\"\"A readable name for the server.\"\"\"<br>        pass<br>    @abc.abstractmethod<br>    async def cleanup(self):<br>        \"\"\"Cleanup the server. For example, this might mean closing a subprocess or<br>        closing a network connection.<br>        \"\"\"<br>        pass<br>    @abc.abstractmethod<br>    async def list_tools(self) -> list[MCPTool]:<br>        \"\"\"List the tools available on the server.\"\"\"<br>        pass<br>    @abc.abstractmethod<br>    async def call_tool(self, tool_name: str, arguments: dict[str, Any] | None) -> CallToolResult:<br>        \"\"\"Invoke a tool on the server.\"\"\"<br>        pass<br>``` |\n\n#### name`abstractmethod``property`\n\n```md-code__content\nname: str\n\n```\n\nA readable name for the server.\n\n#### connect`abstractmethod``async`\n\n```md-code__content\nconnect()\n\n```\n\nConnect to the server. For example, this might mean spawning a subprocess or\nopening a network connection. The server is expected to remain connected until\n`cleanup()` is called.\n\nSource code in `src/agents/mcp/server.py`\n\n|     |     |\n| --- | --- |\n| ```<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>``` | ```md-code__content<br>@abc.abstractmethod<br>async def connect(self):<br>    \"\"\"Connect to the server. For example, this might mean spawning a subprocess or<br>    opening a network connection. The server is expected to remain connected until<br>    `cleanup()` is called.<br>    \"\"\"<br>    pass<br>``` |\n\n#### cleanup`abstractmethod``async`\n\n```md-code__content\ncleanup()\n\n```\n\nCleanup the server. For example, this might mean closing a subprocess or\nclosing a network connection.\n\nSource code in `src/agents/mcp/server.py`\n\n|     |     |\n| --- | --- |\n| ```<br>39<br>40<br>41<br>42<br>43<br>44<br>``` | ```md-code__content<br>@abc.abstractmethod<br>async def cleanup(self):<br>    \"\"\"Cleanup the server. For example, this might mean closing a subprocess or<br>    closing a network connection.<br>    \"\"\"<br>    pass<br>``` |\n\n#### list\\_tools`abstractmethod``async`\n\n```md-code__content\nlist_tools() -> list[Tool]\n\n```\n\nList the tools available on the server.\n\nSource code in `src/agents/mcp/server.py`\n\n|     |     |\n| --- | --- |\n| ```<br>46<br>47<br>48<br>49<br>``` | ```md-code__content<br>@abc.abstractmethod<br>async def list_tools(self) -> list[MCPTool]:<br>    \"\"\"List the tools available on the server.\"\"\"<br>    pass<br>``` |\n\n#### call\\_tool`abstractmethod``async`\n\n```md-code__content\ncall_tool(\n    tool_name: str, arguments: dict[str, Any] | None\n) -> CallToolResult\n\n```\n\nInvoke a tool on the server.\n\nSource code in `src/agents/mcp/server.py`\n\n|     |     |\n| --- | --- |\n| ```<br>51<br>52<br>53<br>54<br>``` | ```md-code__content<br>@abc.abstractmethod<br>async def call_tool(self, tool_name: str, arguments: dict[str, Any] | None) -> CallToolResult:<br>    \"\"\"Invoke a tool on the server.\"\"\"<br>    pass<br>``` |\n\n### MCPServerStdioParams\n\nBases: `TypedDict`\n\nMirrors `mcp.client.stdio.StdioServerParameters`, but lets you pass params without another\nimport.\n\nSource code in `src/agents/mcp/server.py`\n\n|     |     |\n| --- | --- |\n| ```<br>168<br>169<br>170<br>171<br>172<br>173<br>174<br>175<br>176<br>177<br>178<br>179<br>180<br>181<br>182<br>183<br>184<br>185<br>186<br>187<br>188<br>189<br>190<br>191<br>192<br>193<br>194<br>``` | ```md-code__content<br>class MCPServerStdioParams(TypedDict):<br>    \"\"\"Mirrors `mcp.client.stdio.StdioServerParameters`, but lets you pass params without another<br>    import.<br>    \"\"\"<br>    command: str<br>    \"\"\"The executable to run to start the server. For example, `python` or `node`.\"\"\"<br>    args: NotRequired[list[str]]<br>    \"\"\"Command line args to pass to the `command` executable. For example, `['foo.py']` or<br>    `['server.js', '--port', '8080']`.\"\"\"<br>    env: NotRequired[dict[str, str]]<br>    \"\"\"The environment variables to set for the server. .\"\"\"<br>    cwd: NotRequired[str | Path]<br>    \"\"\"The working directory to use when spawning the process.\"\"\"<br>    encoding: NotRequired[str]<br>    \"\"\"The text encoding used when sending/receiving messages to the server. Defaults to `utf-8`.\"\"\"<br>    encoding_error_handler: NotRequired[Literal[\"strict\", \"ignore\", \"replace\"]]<br>    \"\"\"The text encoding error handler. Defaults to `strict`.<br>    See https://docs.python.org/3/library/codecs.html#codec-base-classes for<br>    explanations of possible values.<br>    \"\"\"<br>``` |\n\n#### command`instance-attribute`\n\n```md-code__content\ncommand: str\n\n```\n\nThe executable to run to start the server. For example, `python` or `node`.\n\n#### args`instance-attribute`\n\n```md-code__content\nargs: NotRequired[list[str]]\n\n```\n\nCommand line args to pass to the `command` executable. For example, `['foo.py']` or\n`['server.js', '--port', '8080']`.\n\n#### env`instance-attribute`\n\n```md-code__content\nenv: NotRequired[dict[str, str]]\n\n```\n\nThe environment variables to set for the server. .\n\n#### cwd`instance-attribute`\n\n```md-code__content\ncwd: NotRequired[str | Path]\n\n```\n\nThe working directory to use when spawning the process.\n\n#### encoding`instance-attribute`\n\n```md-code__content\nencoding: NotRequired[str]\n\n```\n\nThe text encoding used when sending/receiving messages to the server. Defaults to `utf-8`.\n\n#### encoding\\_error\\_handler`instance-attribute`\n\n```md-code__content\nencoding_error_handler: NotRequired[\\\n    Literal[\"strict\", \"ignore\", \"replace\"]\\\n]\n\n```\n\nThe text encoding error handler. Defaults to `strict`.\n\nSee https://docs.python.org/3/library/codecs.html#codec-base-classes for\nexplanations of possible values.\n\n### MCPServerStdio\n\nBases: `_MCPServerWithClientSession`\n\nMCP server implementation that uses the stdio transport. See the \\[spec\\]\n(https://spec.modelcontextprotocol.io/specification/2024-11-05/basic/transports/#stdio) for\ndetails.\n\nSource code in `src/agents/mcp/server.py`\n\n|     |     |\n| --- | --- |\n| ```<br>197<br>198<br>199<br>200<br>201<br>202<br>203<br>204<br>205<br>206<br>207<br>208<br>209<br>210<br>211<br>212<br>213<br>214<br>215<br>216<br>217<br>218<br>219<br>220<br>221<br>222<br>223<br>224<br>225<br>226<br>227<br>228<br>229<br>230<br>231<br>232<br>233<br>234<br>235<br>236<br>237<br>238<br>239<br>240<br>241<br>242<br>243<br>244<br>245<br>246<br>247<br>248<br>249<br>250<br>251<br>252<br>253<br>254<br>255<br>``` | ```md-code__content<br>class MCPServerStdio(_MCPServerWithClientSession):<br>    \"\"\"MCP server implementation that uses the stdio transport. See the [spec]<br>    (https://spec.modelcontextprotocol.io/specification/2024-11-05/basic/transports/#stdio) for<br>    details.<br>    \"\"\"<br>    def __init__(<br>        self,<br>        params: MCPServerStdioParams,<br>        cache_tools_list: bool = False,<br>        name: str | None = None,<br>        client_session_timeout_seconds: float | None = 5,<br>    ):<br>        \"\"\"Create a new MCP server based on the stdio transport.<br>        Args:<br>            params: The params that configure the server. This includes the command to run to<br>                start the server, the args to pass to the command, the environment variables to<br>                set for the server, the working directory to use when spawning the process, and<br>                the text encoding used when sending/receiving messages to the server.<br>            cache_tools_list: Whether to cache the tools list. If `True`, the tools list will be<br>                cached and only fetched from the server once. If `False`, the tools list will be<br>                fetched from the server on each call to `list_tools()`. The cache can be<br>                invalidated by calling `invalidate_tools_cache()`. You should set this to `True`<br>                if you know the server will not change its tools list, because it can drastically<br>                improve latency (by avoiding a round-trip to the server every time).<br>            name: A readable name for the server. If not provided, we'll create one from the<br>                command.<br>            client_session_timeout_seconds: the read timeout passed to the MCP ClientSession.<br>        \"\"\"<br>        super().__init__(cache_tools_list, client_session_timeout_seconds)<br>        self.params = StdioServerParameters(<br>            command=params[\"command\"],<br>            args=params.get(\"args\", []),<br>            env=params.get(\"env\"),<br>            cwd=params.get(\"cwd\"),<br>            encoding=params.get(\"encoding\", \"utf-8\"),<br>            encoding_error_handler=params.get(\"encoding_error_handler\", \"strict\"),<br>        )<br>        self._name = name or f\"stdio: {self.params.command}\"<br>    def create_streams(<br>        self,<br>    ) -> AbstractAsyncContextManager[<br>        tuple[<br>            MemoryObjectReceiveStream[SessionMessage | Exception],<br>            MemoryObjectSendStream[SessionMessage],<br>            GetSessionIdCallback | None,<br>        ]<br>    ]:<br>        \"\"\"Create the streams for the server.\"\"\"<br>        return stdio_client(self.params)<br>    @property<br>    def name(self) -> str:<br>        \"\"\"A readable name for the server.\"\"\"<br>        return self._name<br>``` |\n\n#### name`property`\n\n```md-code__content\nname: str\n\n```\n\nA readable name for the server.\n\n#### \\_\\_init\\_\\_\n\n```md-code__content\n__init__(\n    params: MCPServerStdioParams,\n    cache_tools_list: bool = False,\n    name: str | None = None,\n    client_session_timeout_seconds: float | None = 5,\n)\n\n```\n\nCreate a new MCP server based on the stdio transport.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `params` | `MCPServerStdioParams` | The params that configure the server. This includes the command to run to<br>start the server, the args to pass to the command, the environment variables to<br>set for the server, the working directory to use when spawning the process, and<br>the text encoding used when sending/receiving messages to the server. | _required_ |\n| `cache_tools_list` | `bool` | Whether to cache the tools list. If `True`, the tools list will be<br>cached and only fetched from the server once. If `False`, the tools list will be<br>fetched from the server on each call to `list_tools()`. The cache can be<br>invalidated by calling `invalidate_tools_cache()`. You should set this to `True`<br>if you know the server will not change its tools list, because it can drastically<br>improve latency (by avoiding a round-trip to the server every time). | `False` |\n| `name` | `str | None` | A readable name for the server. If not provided, we'll create one from the<br>command. | `None` |\n| `client_session_timeout_seconds` | `float | None` | the read timeout passed to the MCP ClientSession. | `5` |\n\nSource code in `src/agents/mcp/server.py`\n\n|     |     |\n| --- | --- |\n| ```<br>203<br>204<br>205<br>206<br>207<br>208<br>209<br>210<br>211<br>212<br>213<br>214<br>215<br>216<br>217<br>218<br>219<br>220<br>221<br>222<br>223<br>224<br>225<br>226<br>227<br>228<br>229<br>230<br>231<br>232<br>233<br>234<br>235<br>236<br>237<br>238<br>``` | ```md-code__content<br>def __init__(<br>    self,<br>    params: MCPServerStdioParams,<br>    cache_tools_list: bool = False,<br>    name: str | None = None,<br>    client_session_timeout_seconds: float | None = 5,<br>):<br>    \"\"\"Create a new MCP server based on the stdio transport.<br>    Args:<br>        params: The params that configure the server. This includes the command to run to<br>            start the server, the args to pass to the command, the environment variables to<br>            set for the server, the working directory to use when spawning the process, and<br>            the text encoding used when sending/receiving messages to the server.<br>        cache_tools_list: Whether to cache the tools list. If `True`, the tools list will be<br>            cached and only fetched from the server once. If `False`, the tools list will be<br>            fetched from the server on each call to `list_tools()`. The cache can be<br>            invalidated by calling `invalidate_tools_cache()`. You should set this to `True`<br>            if you know the server will not change its tools list, because it can drastically<br>            improve latency (by avoiding a round-trip to the server every time).<br>        name: A readable name for the server. If not provided, we'll create one from the<br>            command.<br>        client_session_timeout_seconds: the read timeout passed to the MCP ClientSession.<br>    \"\"\"<br>    super().__init__(cache_tools_list, client_session_timeout_seconds)<br>    self.params = StdioServerParameters(<br>        command=params[\"command\"],<br>        args=params.get(\"args\", []),<br>        env=params.get(\"env\"),<br>        cwd=params.get(\"cwd\"),<br>        encoding=params.get(\"encoding\", \"utf-8\"),<br>        encoding_error_handler=params.get(\"encoding_error_handler\", \"strict\"),<br>    )<br>    self._name = name or f\"stdio: {self.params.command}\"<br>``` |\n\n#### create\\_streams\n\n```md-code__content\ncreate_streams() -> AbstractAsyncContextManager[\\\n    tuple[\\\n        MemoryObjectReceiveStream[\\\n            SessionMessage | Exception\\\n        ],\\\n        MemoryObjectSendStream[SessionMessage],\\\n        GetSessionIdCallback | None,\\\n    ]\\\n]\n\n```\n\nCreate the streams for the server.\n\nSource code in `src/agents/mcp/server.py`\n\n|     |     |\n| --- | --- |\n| ```<br>240<br>241<br>242<br>243<br>244<br>245<br>246<br>247<br>248<br>249<br>250<br>``` | ```md-code__content<br>def create_streams(<br>    self,<br>) -> AbstractAsyncContextManager[<br>    tuple[<br>        MemoryObjectReceiveStream[SessionMessage | Exception],<br>        MemoryObjectSendStream[SessionMessage],<br>        GetSessionIdCallback | None,<br>    ]<br>]:<br>    \"\"\"Create the streams for the server.\"\"\"<br>    return stdio_client(self.params)<br>``` |\n\n#### connect`async`\n\n```md-code__content\nconnect()\n\n```\n\nConnect to the server.\n\nSource code in `src/agents/mcp/server.py`\n\n|     |     |\n| --- | --- |\n| ```<br>108<br>109<br>110<br>111<br>112<br>113<br>114<br>115<br>116<br>117<br>118<br>119<br>120<br>121<br>122<br>123<br>124<br>125<br>126<br>127<br>128<br>129<br>130<br>131<br>132<br>``` | ```md-code__content<br>async def connect(self):<br>    \"\"\"Connect to the server.\"\"\"<br>    try:<br>        transport = await self.exit_stack.enter_async_context(self.create_streams())<br>        # streamablehttp_client returns (read, write, get_session_id)<br>        # sse_client returns (read, write)<br>        read, write, *_ = transport<br>        session = await self.exit_stack.enter_async_context(<br>            ClientSession(<br>                read,<br>                write,<br>                timedelta(seconds=self.client_session_timeout_seconds)<br>                if self.client_session_timeout_seconds<br>                else None,<br>            )<br>        )<br>        server_result = await session.initialize()<br>        self.server_initialize_result = server_result<br>        self.session = session<br>    except Exception as e:<br>        logger.error(f\"Error initializing MCP server: {e}\")<br>        await self.cleanup()<br>        raise<br>``` |\n\n#### cleanup`async`\n\n```md-code__content\ncleanup()\n\n```\n\nCleanup the server.\n\nSource code in `src/agents/mcp/server.py`\n\n|     |     |\n| --- | --- |\n| ```<br>157<br>158<br>159<br>160<br>161<br>162<br>163<br>164<br>165<br>``` | ```md-code__content<br>async def cleanup(self):<br>    \"\"\"Cleanup the server.\"\"\"<br>    async with self._cleanup_lock:<br>        try:<br>            await self.exit_stack.aclose()<br>        except Exception as e:<br>            logger.error(f\"Error cleaning up server: {e}\")<br>        finally:<br>            self.session = None<br>``` |\n\n#### list\\_tools`async`\n\n```md-code__content\nlist_tools() -> list[Tool]\n\n```\n\nList the tools available on the server.\n\nSource code in `src/agents/mcp/server.py`\n\n|     |     |\n| --- | --- |\n| ```<br>134<br>135<br>136<br>137<br>138<br>139<br>140<br>141<br>142<br>143<br>144<br>145<br>146<br>147<br>148<br>``` | ```md-code__content<br>async def list_tools(self) -> list[MCPTool]:<br>    \"\"\"List the tools available on the server.\"\"\"<br>    if not self.session:<br>        raise UserError(\"Server not initialized. Make sure you call `connect()` first.\")<br>    # Return from cache if caching is enabled, we have tools, and the cache is not dirty<br>    if self.cache_tools_list and not self._cache_dirty and self._tools_list:<br>        return self._tools_list<br>    # Reset the cache dirty to False<br>    self._cache_dirty = False<br>    # Fetch the tools from the server<br>    self._tools_list = (await self.session.list_tools()).tools<br>    return self._tools_list<br>``` |\n\n#### call\\_tool`async`\n\n```md-code__content\ncall_tool(\n    tool_name: str, arguments: dict[str, Any] | None\n) -> CallToolResult\n\n```\n\nInvoke a tool on the server.\n\nSource code in `src/agents/mcp/server.py`\n\n|     |     |\n| --- | --- |\n| ```<br>150<br>151<br>152<br>153<br>154<br>155<br>``` | ```md-code__content<br>async def call_tool(self, tool_name: str, arguments: dict[str, Any] | None) -> CallToolResult:<br>    \"\"\"Invoke a tool on the server.\"\"\"<br>    if not self.session:<br>        raise UserError(\"Server not initialized. Make sure you call `connect()` first.\")<br>    return await self.session.call_tool(tool_name, arguments)<br>``` |\n\n#### invalidate\\_tools\\_cache\n\n```md-code__content\ninvalidate_tools_cache()\n\n```\n\nInvalidate the tools cache.\n\nSource code in `src/agents/mcp/server.py`\n\n|     |     |\n| --- | --- |\n| ```<br>104<br>105<br>106<br>``` | ```md-code__content<br>def invalidate_tools_cache(self):<br>    \"\"\"Invalidate the tools cache.\"\"\"<br>    self._cache_dirty = True<br>``` |\n\n### MCPServerSseParams\n\nBases: `TypedDict`\n\nMirrors the params in `mcp.client.sse.sse_client`.\n\nSource code in `src/agents/mcp/server.py`\n\n|     |     |\n| --- | --- |\n| ```<br>258<br>259<br>260<br>261<br>262<br>263<br>264<br>265<br>266<br>267<br>268<br>269<br>270<br>271<br>``` | ```md-code__content<br>class MCPServerSseParams(TypedDict):<br>    \"\"\"Mirrors the params in`mcp.client.sse.sse_client`.\"\"\"<br>    url: str<br>    \"\"\"The URL of the server.\"\"\"<br>    headers: NotRequired[dict[str, str]]<br>    \"\"\"The headers to send to the server.\"\"\"<br>    timeout: NotRequired[float]<br>    \"\"\"The timeout for the HTTP request. Defaults to 5 seconds.\"\"\"<br>    sse_read_timeout: NotRequired[float]<br>    \"\"\"The timeout for the SSE connection, in seconds. Defaults to 5 minutes.\"\"\"<br>``` |\n\n#### url`instance-attribute`\n\n```md-code__content\nurl: str\n\n```\n\nThe URL of the server.\n\n#### headers`instance-attribute`\n\n```md-code__content\nheaders: NotRequired[dict[str, str]]\n\n```\n\nThe headers to send to the server.\n\n#### timeout`instance-attribute`\n\n```md-code__content\ntimeout: NotRequired[float]\n\n```\n\nThe timeout for the HTTP request. Defaults to 5 seconds.\n\n#### sse\\_read\\_timeout`instance-attribute`\n\n```md-code__content\nsse_read_timeout: NotRequired[float]\n\n```\n\nThe timeout for the SSE connection, in seconds. Defaults to 5 minutes.\n\n### MCPServerSse\n\nBases: `_MCPServerWithClientSession`\n\nMCP server implementation that uses the HTTP with SSE transport. See the \\[spec\\]\n(https://spec.modelcontextprotocol.io/specification/2024-11-05/basic/transports/#http-with-sse)\nfor details.\n\nSource code in `src/agents/mcp/server.py`\n\n|     |     |\n| --- | --- |\n| ```<br>274<br>275<br>276<br>277<br>278<br>279<br>280<br>281<br>282<br>283<br>284<br>285<br>286<br>287<br>288<br>289<br>290<br>291<br>292<br>293<br>294<br>295<br>296<br>297<br>298<br>299<br>300<br>301<br>302<br>303<br>304<br>305<br>306<br>307<br>308<br>309<br>310<br>311<br>312<br>313<br>314<br>315<br>316<br>317<br>318<br>319<br>320<br>321<br>322<br>323<br>324<br>325<br>326<br>327<br>328<br>329<br>330<br>331<br>``` | ```md-code__content<br>class MCPServerSse(_MCPServerWithClientSession):<br>    \"\"\"MCP server implementation that uses the HTTP with SSE transport. See the [spec]<br>    (https://spec.modelcontextprotocol.io/specification/2024-11-05/basic/transports/#http-with-sse)<br>    for details.<br>    \"\"\"<br>    def __init__(<br>        self,<br>        params: MCPServerSseParams,<br>        cache_tools_list: bool = False,<br>        name: str | None = None,<br>        client_session_timeout_seconds: float | None = 5,<br>    ):<br>        \"\"\"Create a new MCP server based on the HTTP with SSE transport.<br>        Args:<br>            params: The params that configure the server. This includes the URL of the server,<br>                the headers to send to the server, the timeout for the HTTP request, and the<br>                timeout for the SSE connection.<br>            cache_tools_list: Whether to cache the tools list. If `True`, the tools list will be<br>                cached and only fetched from the server once. If `False`, the tools list will be<br>                fetched from the server on each call to `list_tools()`. The cache can be<br>                invalidated by calling `invalidate_tools_cache()`. You should set this to `True`<br>                if you know the server will not change its tools list, because it can drastically<br>                improve latency (by avoiding a round-trip to the server every time).<br>            name: A readable name for the server. If not provided, we'll create one from the<br>                URL.<br>            client_session_timeout_seconds: the read timeout passed to the MCP ClientSession.<br>        \"\"\"<br>        super().__init__(cache_tools_list, client_session_timeout_seconds)<br>        self.params = params<br>        self._name = name or f\"sse: {self.params['url']}\"<br>    def create_streams(<br>        self,<br>    ) -> AbstractAsyncContextManager[<br>        tuple[<br>            MemoryObjectReceiveStream[SessionMessage | Exception],<br>            MemoryObjectSendStream[SessionMessage],<br>            GetSessionIdCallback | None,<br>        ]<br>    ]:<br>        \"\"\"Create the streams for the server.\"\"\"<br>        return sse_client(<br>            url=self.params[\"url\"],<br>            headers=self.params.get(\"headers\", None),<br>            timeout=self.params.get(\"timeout\", 5),<br>            sse_read_timeout=self.params.get(\"sse_read_timeout\", 60 * 5),<br>        )<br>    @property<br>    def name(self) -> str:<br>        \"\"\"A readable name for the server.\"\"\"<br>        return self._name<br>``` |\n\n#### name`property`\n\n```md-code__content\nname: str\n\n```\n\nA readable name for the server.\n\n#### \\_\\_init\\_\\_\n\n```md-code__content\n__init__(\n    params: MCPServerSseParams,\n    cache_tools_list: bool = False,\n    name: str | None = None,\n    client_session_timeout_seconds: float | None = 5,\n)\n\n```\n\nCreate a new MCP server based on the HTTP with SSE transport.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `params` | `MCPServerSseParams` | The params that configure the server. This includes the URL of the server,<br>the headers to send to the server, the timeout for the HTTP request, and the<br>timeout for the SSE connection. | _required_ |\n| `cache_tools_list` | `bool` | Whether to cache the tools list. If `True`, the tools list will be<br>cached and only fetched from the server once. If `False`, the tools list will be<br>fetched from the server on each call to `list_tools()`. The cache can be<br>invalidated by calling `invalidate_tools_cache()`. You should set this to `True`<br>if you know the server will not change its tools list, because it can drastically<br>improve latency (by avoiding a round-trip to the server every time). | `False` |\n| `name` | `str | None` | A readable name for the server. If not provided, we'll create one from the<br>URL. | `None` |\n| `client_session_timeout_seconds` | `float | None` | the read timeout passed to the MCP ClientSession. | `5` |\n\nSource code in `src/agents/mcp/server.py`\n\n|     |     |\n| --- | --- |\n| ```<br>280<br>281<br>282<br>283<br>284<br>285<br>286<br>287<br>288<br>289<br>290<br>291<br>292<br>293<br>294<br>295<br>296<br>297<br>298<br>299<br>300<br>301<br>302<br>303<br>304<br>305<br>306<br>307<br>308<br>309<br>``` | ```md-code__content<br>def __init__(<br>    self,<br>    params: MCPServerSseParams,<br>    cache_tools_list: bool = False,<br>    name: str | None = None,<br>    client_session_timeout_seconds: float | None = 5,<br>):<br>    \"\"\"Create a new MCP server based on the HTTP with SSE transport.<br>    Args:<br>        params: The params that configure the server. This includes the URL of the server,<br>            the headers to send to the server, the timeout for the HTTP request, and the<br>            timeout for the SSE connection.<br>        cache_tools_list: Whether to cache the tools list. If `True`, the tools list will be<br>            cached and only fetched from the server once. If `False`, the tools list will be<br>            fetched from the server on each call to `list_tools()`. The cache can be<br>            invalidated by calling `invalidate_tools_cache()`. You should set this to `True`<br>            if you know the server will not change its tools list, because it can drastically<br>            improve latency (by avoiding a round-trip to the server every time).<br>        name: A readable name for the server. If not provided, we'll create one from the<br>            URL.<br>        client_session_timeout_seconds: the read timeout passed to the MCP ClientSession.<br>    \"\"\"<br>    super().__init__(cache_tools_list, client_session_timeout_seconds)<br>    self.params = params<br>    self._name = name or f\"sse: {self.params['url']}\"<br>``` |\n\n#### create\\_streams\n\n```md-code__content\ncreate_streams() -> AbstractAsyncContextManager[\\\n    tuple[\\\n        MemoryObjectReceiveStream[\\\n            SessionMessage | Exception\\\n        ],\\\n        MemoryObjectSendStream[SessionMessage],\\\n        GetSessionIdCallback | None,\\\n    ]\\\n]\n\n```\n\nCreate the streams for the server.\n\nSource code in `src/agents/mcp/server.py`\n\n|     |     |\n| --- | --- |\n| ```<br>311<br>312<br>313<br>314<br>315<br>316<br>317<br>318<br>319<br>320<br>321<br>322<br>323<br>324<br>325<br>326<br>``` | ```md-code__content<br>def create_streams(<br>    self,<br>) -> AbstractAsyncContextManager[<br>    tuple[<br>        MemoryObjectReceiveStream[SessionMessage | Exception],<br>        MemoryObjectSendStream[SessionMessage],<br>        GetSessionIdCallback | None,<br>    ]<br>]:<br>    \"\"\"Create the streams for the server.\"\"\"<br>    return sse_client(<br>        url=self.params[\"url\"],<br>        headers=self.params.get(\"headers\", None),<br>        timeout=self.params.get(\"timeout\", 5),<br>        sse_read_timeout=self.params.get(\"sse_read_timeout\", 60 * 5),<br>    )<br>``` |\n\n#### connect`async`\n\n```md-code__content\nconnect()\n\n```\n\nConnect to the server.\n\nSource code in `src/agents/mcp/server.py`\n\n|     |     |\n| --- | --- |\n| ```<br>108<br>109<br>110<br>111<br>112<br>113<br>114<br>115<br>116<br>117<br>118<br>119<br>120<br>121<br>122<br>123<br>124<br>125<br>126<br>127<br>128<br>129<br>130<br>131<br>132<br>``` | ```md-code__content<br>async def connect(self):<br>    \"\"\"Connect to the server.\"\"\"<br>    try:<br>        transport = await self.exit_stack.enter_async_context(self.create_streams())<br>        # streamablehttp_client returns (read, write, get_session_id)<br>        # sse_client returns (read, write)<br>        read, write, *_ = transport<br>        session = await self.exit_stack.enter_async_context(<br>            ClientSession(<br>                read,<br>                write,<br>                timedelta(seconds=self.client_session_timeout_seconds)<br>                if self.client_session_timeout_seconds<br>                else None,<br>            )<br>        )<br>        server_result = await session.initialize()<br>        self.server_initialize_result = server_result<br>        self.session = session<br>    except Exception as e:<br>        logger.error(f\"Error initializing MCP server: {e}\")<br>        await self.cleanup()<br>        raise<br>``` |\n\n#### cleanup`async`\n\n```md-code__content\ncleanup()\n\n```\n\nCleanup the server.\n\nSource code in `src/agents/mcp/server.py`\n\n|     |     |\n| --- | --- |\n| ```<br>157<br>158<br>159<br>160<br>161<br>162<br>163<br>164<br>165<br>``` | ```md-code__content<br>async def cleanup(self):<br>    \"\"\"Cleanup the server.\"\"\"<br>    async with self._cleanup_lock:<br>        try:<br>            await self.exit_stack.aclose()<br>        except Exception as e:<br>            logger.error(f\"Error cleaning up server: {e}\")<br>        finally:<br>            self.session = None<br>``` |\n\n#### list\\_tools`async`\n\n```md-code__content\nlist_tools() -> list[Tool]\n\n```\n\nList the tools available on the server.\n\nSource code in `src/agents/mcp/server.py`\n\n|     |     |\n| --- | --- |\n| ```<br>134<br>135<br>136<br>137<br>138<br>139<br>140<br>141<br>142<br>143<br>144<br>145<br>146<br>147<br>148<br>``` | ```md-code__content<br>async def list_tools(self) -> list[MCPTool]:<br>    \"\"\"List the tools available on the server.\"\"\"<br>    if not self.session:<br>        raise UserError(\"Server not initialized. Make sure you call `connect()` first.\")<br>    # Return from cache if caching is enabled, we have tools, and the cache is not dirty<br>    if self.cache_tools_list and not self._cache_dirty and self._tools_list:<br>        return self._tools_list<br>    # Reset the cache dirty to False<br>    self._cache_dirty = False<br>    # Fetch the tools from the server<br>    self._tools_list = (await self.session.list_tools()).tools<br>    return self._tools_list<br>``` |\n\n#### call\\_tool`async`\n\n```md-code__content\ncall_tool(\n    tool_name: str, arguments: dict[str, Any] | None\n) -> CallToolResult\n\n```\n\nInvoke a tool on the server.\n\nSource code in `src/agents/mcp/server.py`\n\n|     |     |\n| --- | --- |\n| ```<br>150<br>151<br>152<br>153<br>154<br>155<br>``` | ```md-code__content<br>async def call_tool(self, tool_name: str, arguments: dict[str, Any] | None) -> CallToolResult:<br>    \"\"\"Invoke a tool on the server.\"\"\"<br>    if not self.session:<br>        raise UserError(\"Server not initialized. Make sure you call `connect()` first.\")<br>    return await self.session.call_tool(tool_name, arguments)<br>``` |\n\n#### invalidate\\_tools\\_cache\n\n```md-code__content\ninvalidate_tools_cache()\n\n```\n\nInvalidate the tools cache.\n\nSource code in `src/agents/mcp/server.py`\n\n|     |     |\n| --- | --- |\n| ```<br>104<br>105<br>106<br>``` | ```md-code__content<br>def invalidate_tools_cache(self):<br>    \"\"\"Invalidate the tools cache.\"\"\"<br>    self._cache_dirty = True<br>``` |\n\n### MCPServerStreamableHttpParams\n\nBases: `TypedDict`\n\nMirrors the params in `mcp.client.streamable_http.streamablehttp_client`.\n\nSource code in `src/agents/mcp/server.py`\n\n|     |     |\n| --- | --- |\n| ```<br>334<br>335<br>336<br>337<br>338<br>339<br>340<br>341<br>342<br>343<br>344<br>345<br>346<br>347<br>348<br>349<br>350<br>``` | ```md-code__content<br>class MCPServerStreamableHttpParams(TypedDict):<br>    \"\"\"Mirrors the params in`mcp.client.streamable_http.streamablehttp_client`.\"\"\"<br>    url: str<br>    \"\"\"The URL of the server.\"\"\"<br>    headers: NotRequired[dict[str, str]]<br>    \"\"\"The headers to send to the server.\"\"\"<br>    timeout: NotRequired[timedelta | float]<br>    \"\"\"The timeout for the HTTP request. Defaults to 5 seconds.\"\"\"<br>    sse_read_timeout: NotRequired[timedelta | float]<br>    \"\"\"The timeout for the SSE connection, in seconds. Defaults to 5 minutes.\"\"\"<br>    terminate_on_close: NotRequired[bool]<br>    \"\"\"Terminate on close\"\"\"<br>``` |\n\n#### url`instance-attribute`\n\n```md-code__content\nurl: str\n\n```\n\nThe URL of the server.\n\n#### headers`instance-attribute`\n\n```md-code__content\nheaders: NotRequired[dict[str, str]]\n\n```\n\nThe headers to send to the server.\n\n#### timeout`instance-attribute`\n\n```md-code__content\ntimeout: NotRequired[timedelta | float]\n\n```\n\nThe timeout for the HTTP request. Defaults to 5 seconds.\n\n#### sse\\_read\\_timeout`instance-attribute`\n\n```md-code__content\nsse_read_timeout: NotRequired[timedelta | float]\n\n```\n\nThe timeout for the SSE connection, in seconds. Defaults to 5 minutes.\n\n#### terminate\\_on\\_close`instance-attribute`\n\n```md-code__content\nterminate_on_close: NotRequired[bool]\n\n```\n\nTerminate on close\n\n### MCPServerStreamableHttp\n\nBases: `_MCPServerWithClientSession`\n\nMCP server implementation that uses the Streamable HTTP transport. See the \\[spec\\]\n(https://modelcontextprotocol.io/specification/2025-03-26/basic/transports#streamable-http)\nfor details.\n\nSource code in `src/agents/mcp/server.py`\n\n|     |     |\n| --- | --- |\n| ```<br>353<br>354<br>355<br>356<br>357<br>358<br>359<br>360<br>361<br>362<br>363<br>364<br>365<br>366<br>367<br>368<br>369<br>370<br>371<br>372<br>373<br>374<br>375<br>376<br>377<br>378<br>379<br>380<br>381<br>382<br>383<br>384<br>385<br>386<br>387<br>388<br>389<br>390<br>391<br>392<br>393<br>394<br>395<br>396<br>397<br>398<br>399<br>400<br>401<br>402<br>403<br>404<br>405<br>406<br>407<br>408<br>409<br>410<br>411<br>412<br>``` | ```md-code__content<br>class MCPServerStreamableHttp(_MCPServerWithClientSession):<br>    \"\"\"MCP server implementation that uses the Streamable HTTP transport. See the [spec]<br>    (https://modelcontextprotocol.io/specification/2025-03-26/basic/transports#streamable-http)<br>    for details.<br>    \"\"\"<br>    def __init__(<br>        self,<br>        params: MCPServerStreamableHttpParams,<br>        cache_tools_list: bool = False,<br>        name: str | None = None,<br>        client_session_timeout_seconds: float | None = 5,<br>    ):<br>        \"\"\"Create a new MCP server based on the Streamable HTTP transport.<br>        Args:<br>            params: The params that configure the server. This includes the URL of the server,<br>                the headers to send to the server, the timeout for the HTTP request, and the<br>                timeout for the Streamable HTTP connection and whether we need to<br>                terminate on close.<br>            cache_tools_list: Whether to cache the tools list. If `True`, the tools list will be<br>                cached and only fetched from the server once. If `False`, the tools list will be<br>                fetched from the server on each call to `list_tools()`. The cache can be<br>                invalidated by calling `invalidate_tools_cache()`. You should set this to `True`<br>                if you know the server will not change its tools list, because it can drastically<br>                improve latency (by avoiding a round-trip to the server every time).<br>            name: A readable name for the server. If not provided, we'll create one from the<br>                URL.<br>            client_session_timeout_seconds: the read timeout passed to the MCP ClientSession.<br>        \"\"\"<br>        super().__init__(cache_tools_list, client_session_timeout_seconds)<br>        self.params = params<br>        self._name = name or f\"streamable_http: {self.params['url']}\"<br>    def create_streams(<br>        self,<br>    ) -> AbstractAsyncContextManager[<br>        tuple[<br>            MemoryObjectReceiveStream[SessionMessage | Exception],<br>            MemoryObjectSendStream[SessionMessage],<br>            GetSessionIdCallback | None,<br>        ]<br>    ]:<br>        \"\"\"Create the streams for the server.\"\"\"<br>        return streamablehttp_client(<br>            url=self.params[\"url\"],<br>            headers=self.params.get(\"headers\", None),<br>            timeout=self.params.get(\"timeout\", 5),<br>            sse_read_timeout=self.params.get(\"sse_read_timeout\", 60 * 5),<br>            terminate_on_close=self.params.get(\"terminate_on_close\", True),<br>        )<br>    @property<br>    def name(self) -> str:<br>        \"\"\"A readable name for the server.\"\"\"<br>        return self._name<br>``` |\n\n#### name`property`\n\n```md-code__content\nname: str\n\n```\n\nA readable name for the server.\n\n#### \\_\\_init\\_\\_\n\n```md-code__content\n__init__(\n    params: MCPServerStreamableHttpParams,\n    cache_tools_list: bool = False,\n    name: str | None = None,\n    client_session_timeout_seconds: float | None = 5,\n)\n\n```\n\nCreate a new MCP server based on the Streamable HTTP transport.\n\nParameters:\n\n| Name | Type | Description | Default |\n| --- | --- | --- | --- |\n| `params` | `MCPServerStreamableHttpParams` | The params that configure the server. This includes the URL of the server,<br>the headers to send to the server, the timeout for the HTTP request, and the<br>timeout for the Streamable HTTP connection and whether we need to<br>terminate on close. | _required_ |\n| `cache_tools_list` | `bool` | Whether to cache the tools list. If `True`, the tools list will be<br>cached and only fetched from the server once. If `False`, the tools list will be<br>fetched from the server on each call to `list_tools()`. The cache can be<br>invalidated by calling `invalidate_tools_cache()`. You should set this to `True`<br>if you know the server will not change its tools list, because it can drastically<br>improve latency (by avoiding a round-trip to the server every time). | `False` |\n| `name` | `str | None` | A readable name for the server. If not provided, we'll create one from the<br>URL. | `None` |\n| `client_session_timeout_seconds` | `float | None` | the read timeout passed to the MCP ClientSession. | `5` |\n\nSource code in `src/agents/mcp/server.py`\n\n|     |     |\n| --- | --- |\n| ```<br>359<br>360<br>361<br>362<br>363<br>364<br>365<br>366<br>367<br>368<br>369<br>370<br>371<br>372<br>373<br>374<br>375<br>376<br>377<br>378<br>379<br>380<br>381<br>382<br>383<br>384<br>385<br>386<br>387<br>388<br>389<br>``` | ```md-code__content<br>def __init__(<br>    self,<br>    params: MCPServerStreamableHttpParams,<br>    cache_tools_list: bool = False,<br>    name: str | None = None,<br>    client_session_timeout_seconds: float | None = 5,<br>):<br>    \"\"\"Create a new MCP server based on the Streamable HTTP transport.<br>    Args:<br>        params: The params that configure the server. This includes the URL of the server,<br>            the headers to send to the server, the timeout for the HTTP request, and the<br>            timeout for the Streamable HTTP connection and whether we need to<br>            terminate on close.<br>        cache_tools_list: Whether to cache the tools list. If `True`, the tools list will be<br>            cached and only fetched from the server once. If `False`, the tools list will be<br>            fetched from the server on each call to `list_tools()`. The cache can be<br>            invalidated by calling `invalidate_tools_cache()`. You should set this to `True`<br>            if you know the server will not change its tools list, because it can drastically<br>            improve latency (by avoiding a round-trip to the server every time).<br>        name: A readable name for the server. If not provided, we'll create one from the<br>            URL.<br>        client_session_timeout_seconds: the read timeout passed to the MCP ClientSession.<br>    \"\"\"<br>    super().__init__(cache_tools_list, client_session_timeout_seconds)<br>    self.params = params<br>    self._name = name or f\"streamable_http: {self.params['url']}\"<br>``` |\n\n#### create\\_streams\n\n```md-code__content\ncreate_streams() -> AbstractAsyncContextManager[\\\n    tuple[\\\n        MemoryObjectReceiveStream[\\\n            SessionMessage | Exception\\\n        ],\\\n        MemoryObjectSendStream[SessionMessage],\\\n        GetSessionIdCallback | None,\\\n    ]\\\n]\n\n```\n\nCreate the streams for the server.\n\nSource code in `src/agents/mcp/server.py`\n\n|     |     |\n| --- | --- |\n| ```<br>391<br>392<br>393<br>394<br>395<br>396<br>397<br>398<br>399<br>400<br>401<br>402<br>403<br>404<br>405<br>406<br>407<br>``` | ```md-code__content<br>def create_streams(<br>    self,<br>) -> AbstractAsyncContextManager[<br>    tuple[<br>        MemoryObjectReceiveStream[SessionMessage | Exception],<br>        MemoryObjectSendStream[SessionMessage],<br>        GetSessionIdCallback | None,<br>    ]<br>]:<br>    \"\"\"Create the streams for the server.\"\"\"<br>    return streamablehttp_client(<br>        url=self.params[\"url\"],<br>        headers=self.params.get(\"headers\", None),<br>        timeout=self.params.get(\"timeout\", 5),<br>        sse_read_timeout=self.params.get(\"sse_read_timeout\", 60 * 5),<br>        terminate_on_close=self.params.get(\"terminate_on_close\", True),<br>    )<br>``` |\n\n#### connect`async`\n\n```md-code__content\nconnect()\n\n```\n\nConnect to the server.\n\nSource code in `src/agents/mcp/server.py`\n\n|     |     |\n| --- | --- |\n| ```<br>108<br>109<br>110<br>111<br>112<br>113<br>114<br>115<br>116<br>117<br>118<br>119<br>120<br>121<br>122<br>123<br>124<br>125<br>126<br>127<br>128<br>129<br>130<br>131<br>132<br>``` | ```md-code__content<br>async def connect(self):<br>    \"\"\"Connect to the server.\"\"\"<br>    try:<br>        transport = await self.exit_stack.enter_async_context(self.create_streams())<br>        # streamablehttp_client returns (read, write, get_session_id)<br>        # sse_client returns (read, write)<br>        read, write, *_ = transport<br>        session = await self.exit_stack.enter_async_context(<br>            ClientSession(<br>                read,<br>                write,<br>                timedelta(seconds=self.client_session_timeout_seconds)<br>                if self.client_session_timeout_seconds<br>                else None,<br>            )<br>        )<br>        server_result = await session.initialize()<br>        self.server_initialize_result = server_result<br>        self.session = session<br>    except Exception as e:<br>        logger.error(f\"Error initializing MCP server: {e}\")<br>        await self.cleanup()<br>        raise<br>``` |\n\n#### cleanup`async`\n\n```md-code__content\ncleanup()\n\n```\n\nCleanup the server.\n\nSource code in `src/agents/mcp/server.py`\n\n|     |     |\n| --- | --- |\n| ```<br>157<br>158<br>159<br>160<br>161<br>162<br>163<br>164<br>165<br>``` | ```md-code__content<br>async def cleanup(self):<br>    \"\"\"Cleanup the server.\"\"\"<br>    async with self._cleanup_lock:<br>        try:<br>            await self.exit_stack.aclose()<br>        except Exception as e:<br>            logger.error(f\"Error cleaning up server: {e}\")<br>        finally:<br>            self.session = None<br>``` |\n\n#### list\\_tools`async`\n\n```md-code__content\nlist_tools() -> list[Tool]\n\n```\n\nList the tools available on the server.\n\nSource code in `src/agents/mcp/server.py`\n\n|     |     |\n| --- | --- |\n| ```<br>134<br>135<br>136<br>137<br>138<br>139<br>140<br>141<br>142<br>143<br>144<br>145<br>146<br>147<br>148<br>``` | ```md-code__content<br>async def list_tools(self) -> list[MCPTool]:<br>    \"\"\"List the tools available on the server.\"\"\"<br>    if not self.session:<br>        raise UserError(\"Server not initialized. Make sure you call `connect()` first.\")<br>    # Return from cache if caching is enabled, we have tools, and the cache is not dirty<br>    if self.cache_tools_list and not self._cache_dirty and self._tools_list:<br>        return self._tools_list<br>    # Reset the cache dirty to False<br>    self._cache_dirty = False<br>    # Fetch the tools from the server<br>    self._tools_list = (await self.session.list_tools()).tools<br>    return self._tools_list<br>``` |\n\n#### call\\_tool`async`\n\n```md-code__content\ncall_tool(\n    tool_name: str, arguments: dict[str, Any] | None\n) -> CallToolResult\n\n```\n\nInvoke a tool on the server.\n\nSource code in `src/agents/mcp/server.py`\n\n|     |     |\n| --- | --- |\n| ```<br>150<br>151<br>152<br>153<br>154<br>155<br>``` | ```md-code__content<br>async def call_tool(self, tool_name: str, arguments: dict[str, Any] | None) -> CallToolResult:<br>    \"\"\"Invoke a tool on the server.\"\"\"<br>    if not self.session:<br>        raise UserError(\"Server not initialized. Make sure you call `connect()` first.\")<br>    return await self.session.call_tool(tool_name, arguments)<br>``` |\n\n#### invalidate\\_tools\\_cache\n\n```md-code__content\ninvalidate_tools_cache()\n\n```\n\nInvalidate the tools cache.\n\nSource code in `src/agents/mcp/server.py`\n\n|     |     |\n| --- | --- |\n| ```<br>104<br>105<br>106<br>``` | ```md-code__content<br>def invalidate_tools_cache(self):<br>    \"\"\"Invalidate the tools cache.\"\"\"<br>    self._cache_dirty = True<br>``` |",
  "metadata": {
    "language": "en",
    "favicon": "https://openai.github.io/openai-agents-python/images/favicon-platform.svg",
    "title": "MCP Servers - OpenAI Agents SDK",
    "viewport": "width=device-width,initial-scale=1",
    "generator": "mkdocs-1.6.1, mkdocs-material-9.6.11",
    "scrapeId": "a23b7ac7-879c-4f40-a7d8-2c3bba7f55e0",
    "sourceURL": "https://openai.github.io/openai-agents-python/ref/mcp/server/",
    "url": "https://openai.github.io/openai-agents-python/ref/mcp/server/",
    "statusCode": 200,
    "contentType": "text/html; charset=utf-8",
    "proxyUsed": "basic"
  }
}